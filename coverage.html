
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ghissues: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/JohanCodinha/ghissues/cmd/ghissues/main.go (24.5%)</option>
				
				<option value="file1">github.com/JohanCodinha/ghissues/internal/cache/db.go (49.0%)</option>
				
				<option value="file2">github.com/JohanCodinha/ghissues/internal/fs/fuse.go (73.6%)</option>
				
				<option value="file3">github.com/JohanCodinha/ghissues/internal/gh/client.go (78.3%)</option>
				
				<option value="file4">github.com/JohanCodinha/ghissues/internal/gh/mock_server.go (80.0%)</option>
				
				<option value="file5">github.com/JohanCodinha/ghissues/internal/logger/logger.go (100.0%)</option>
				
				<option value="file6">github.com/JohanCodinha/ghissues/internal/md/format.go (93.9%)</option>
				
				<option value="file7">github.com/JohanCodinha/ghissues/internal/sync/engine.go (76.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the CLI entrypoint for ghissues.
package main

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/JohanCodinha/ghissues/internal/cache"
        "github.com/JohanCodinha/ghissues/internal/fs"
        "github.com/JohanCodinha/ghissues/internal/gh"
        "github.com/JohanCodinha/ghissues/internal/logger"
        "github.com/JohanCodinha/ghissues/internal/sync"
        "github.com/spf13/cobra"
)

// CLI flags for logging configuration
var (
        logLevel string
        logFile  string
        quiet    bool
)

// validateRepo validates the repository format and returns the owner and repo name.
// The format must be "owner/repo" where neither owner nor repo is empty.
func validateRepo(repo string) (owner, name string, err error) <span class="cov8" title="1">{
        if !strings.Contains(repo, "/") </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("invalid repository format %q: must be in the format owner/repo", repo)
        }</span>

        <span class="cov8" title="1">parts := strings.SplitN(repo, "/", 2)
        if parts[0] == "" || parts[1] == "" </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("invalid repository format %q: owner and repo cannot be empty", repo)
        }</span>

        <span class="cov8" title="1">return parts[0], parts[1], nil</span>
}

// ensureMountpoint ensures that the mountpoint exists and is a directory.
// If the mountpoint doesn't exist, it will be created.
// Returns true if the mountpoint was created, false if it already existed.
func ensureMountpoint(path string) (created bool, err error) <span class="cov8" title="1">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov8" title="1">{
                                return false, fmt.Errorf("failed to create mountpoint %q: %w", path, err)
                        }</span>
                        <span class="cov8" title="1">return true, nil</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("cannot access mountpoint %q: %w", path, err)</span>
        }

        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return false, fmt.Errorf("mountpoint %q is not a directory", path)
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}

// getCachePath returns the path to the cache database file for the given repository.
// The cache is stored at ~/.cache/ghissues/{owner}_{repo}.db
func getCachePath(owner, repoName string) (string, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">cacheDir := filepath.Join(homeDir, ".cache", "ghissues")
        if err := os.MkdirAll(cacheDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create cache directory: %w", err)
        }</span>

        <span class="cov8" title="1">return filepath.Join(cacheDir, fmt.Sprintf("%s_%s.db", owner, repoName)), nil</span>
}

// getUnmountCommand returns the appropriate system unmount command for the current OS.
func getUnmountCommand(mountpoint string) *exec.Cmd <span class="cov8" title="1">{
        if runtime.GOOS == "darwin" </span><span class="cov8" title="1">{
                return exec.Command("umount", mountpoint)
        }</span>
        <span class="cov0" title="0">return exec.Command("fusermount", "-u", mountpoint)</span>
}

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

var rootCmd = &amp;cobra.Command{
        Use:   "ghissues",
        Short: "Mount GitHub issues as a FUSE filesystem",
        Long: `ghissues mounts a GitHub repository's issues as markdown files
in a FUSE filesystem, allowing you to read and edit issues
using your favorite text editor.`,
}

var mountCmd = &amp;cobra.Command{
        Use:   "mount &lt;owner/repo&gt; &lt;mountpoint&gt;",
        Short: "Mount a repository's issues as a filesystem",
        Long: `Mount a GitHub repository's issues as markdown files at the specified mountpoint.

The repository must be specified in the format "owner/repo".
The mountpoint must be an existing directory.`,
        Args: cobra.ExactArgs(2),
        RunE: runMount,
}

var unmountCmd = &amp;cobra.Command{
        Use:   "unmount &lt;mountpoint&gt;",
        Short: "Unmount a previously mounted filesystem",
        Long: `Unmount a ghissues filesystem and flush any pending changes to GitHub.

The mountpoint must be an existing directory where ghissues is mounted.`,
        Args: cobra.ExactArgs(1),
        RunE: runUnmount,
}

func init() <span class="cov8" title="1">{
        // Add logging flags to mount command
        mountCmd.Flags().StringVar(&amp;logLevel, "log-level", "info", "Log level (debug, info, warn, error)")
        mountCmd.Flags().StringVar(&amp;logFile, "log-file", "", "Path to log file (logs to stderr if not set)")
        mountCmd.Flags().BoolVarP(&amp;quiet, "quiet", "q", false, "Suppress non-error output")

        rootCmd.AddCommand(mountCmd)
        rootCmd.AddCommand(unmountCmd)
}</span>

func runMount(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        repo := args[0]
        mountpoint := args[1]

        // Configure logging based on CLI flags
        if err := configureLogging(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer logger.Close()

        // Validate repo format
        owner, repoName, err := validateRepo(repo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create mountpoint if it doesn't exist
        <span class="cov0" title="0">created, err := ensureMountpoint(mountpoint)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if created </span><span class="cov0" title="0">{
                logger.Info("created mountpoint %s", mountpoint)
        }</span>

        // 1. Get GitHub auth token
        <span class="cov0" title="0">token, err := gh.GetToken()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get GitHub token: %w\nRun 'gh auth login' to authenticate", err)
        }</span>
        <span class="cov0" title="0">logger.Info("authenticated with GitHub")

        // 2. Create GitHub client
        client := gh.New(token)

        // 3. Determine cache path: ~/.cache/ghissues/{owner}_{repo}.db
        cachePath, err := getCachePath(owner, repoName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 4. Initialize cache
        <span class="cov0" title="0">cacheDB, err := cache.InitDB(cachePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize cache: %w", err)
        }</span>
        <span class="cov0" title="0">logger.Info("cache initialized at %s", cachePath)

        // 5. Create sync engine with 500ms debounce
        engine, err := sync.NewEngine(cacheDB, client, repo, 500)
        if err != nil </span><span class="cov0" title="0">{
                cacheDB.Close()
                return fmt.Errorf("failed to create sync engine: %w", err)
        }</span>

        // 6. Run initial sync
        <span class="cov0" title="0">logger.Info("syncing issues from %s...", repo)
        if err := engine.InitialSync(); err != nil </span><span class="cov0" title="0">{
                // Log warning but continue in offline mode
                logger.Warn("initial sync failed: %v", err)
                logger.Warn("continuing in offline mode with cached data")
        }</span>

        // 7. Create FS with onDirty callback to trigger sync
        <span class="cov0" title="0">filesystem := fs.NewFS(cacheDB, repo, mountpoint, func() </span><span class="cov0" title="0">{
                engine.TriggerSync()
        }</span>)

        // 8. Mount (blocks until unmount)
        <span class="cov0" title="0">logger.Info("mounting %s to %s", repo, mountpoint)
        logger.Info("press Ctrl+C to unmount")
        mountErr := filesystem.Mount()

        // 9. Cleanup on return (after unmount)
        logger.Info("unmounting...")

        // Flush any pending changes
        if err := engine.SyncNow(); err != nil </span><span class="cov0" title="0">{
                logger.Warn("failed to sync pending changes: %v", err)
        }</span>

        // Stop the sync engine
        <span class="cov0" title="0">engine.Stop()

        // Close the cache
        if err := cacheDB.Close(); err != nil </span><span class="cov0" title="0">{
                logger.Warn("failed to close cache: %v", err)
        }</span>

        <span class="cov0" title="0">if mountErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mount error: %w", mountErr)
        }</span>

        <span class="cov0" title="0">logger.Info("unmounted successfully")
        return nil</span>
}

// configureLogging sets up the logger based on CLI flags.
func configureLogging() error <span class="cov0" title="0">{
        // Parse and set log level
        level, err := logger.ParseLevel(logLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If quiet mode, only show errors
        <span class="cov0" title="0">if quiet </span><span class="cov0" title="0">{
                level = logger.LevelError
        }</span>

        <span class="cov0" title="0">logger.SetLevel(level)

        // Set up log file if specified
        if logFile != "" </span><span class="cov0" title="0">{
                if err := logger.SetLogFile(logFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set log file: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func runUnmount(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        mountpoint := args[0]

        // Validate mountpoint exists
        info, err := os.Stat(mountpoint)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("mountpoint %q does not exist", mountpoint)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("cannot access mountpoint %q: %w", mountpoint, err)</span>
        }

        <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("mountpoint %q is not a directory", mountpoint)
        }</span>

        // Get absolute path for the mountpoint
        <span class="cov0" title="0">absMountpoint, err := filepath.Abs(mountpoint)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute path: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("unmounting %s\n", absMountpoint)

        // Call the appropriate system unmount command based on platform
        unmountCommand := getUnmountCommand(absMountpoint)
        unmountCommand.Stdout = os.Stdout
        unmountCommand.Stderr = os.Stderr

        if err := unmountCommand.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmount: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("unmounted successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package cache provides SQLite-based caching for GitHub issues.
package cache

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        _ "modernc.org/sqlite"
)

// DB represents a SQLite database connection for caching issues.
type DB struct {
        path string
        conn *sql.DB
}

// Issue represents a cached issue.
type Issue struct {
        ID             int64
        Number         int
        Repo           string
        Title          string
        Body           string
        State          string
        Author         string
        Labels         []string // Stored as JSON array in database
        CreatedAt      string
        UpdatedAt      string
        ETag           string
        Dirty          bool
        LocalUpdatedAt string
}

// Comment represents a cached issue comment.
type Comment struct {
        ID          int64
        IssueNumber int
        Repo        string
        Author      string
        Body        string
        CreatedAt   string
        UpdatedAt   string
}

// createTableSQL defines the schema for the issues table.
const createTableSQL = `
CREATE TABLE IF NOT EXISTS issues (
    id INTEGER PRIMARY KEY,
    number INTEGER NOT NULL,
    repo TEXT NOT NULL,
    title TEXT NOT NULL,
    body TEXT,
    state TEXT,
    author TEXT,
    labels TEXT,  -- JSON array of label names
    created_at TEXT,
    updated_at TEXT,
    etag TEXT,
    dirty INTEGER DEFAULT 0,
    local_updated_at TEXT,
    UNIQUE(repo, number)
);
`

// createCommentsTableSQL defines the schema for the comments table.
const createCommentsTableSQL = `
CREATE TABLE IF NOT EXISTS comments (
    id INTEGER PRIMARY KEY,
    issue_number INTEGER NOT NULL,
    repo TEXT NOT NULL,
    author TEXT NOT NULL,
    body TEXT,
    created_at TEXT,
    updated_at TEXT,
    dirty INTEGER DEFAULT 0,
    UNIQUE(repo, issue_number, id)
);
`

// createPendingCommentsTableSQL defines the schema for pending new comments.
const createPendingCommentsTableSQL = `
CREATE TABLE IF NOT EXISTS pending_comments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    issue_number INTEGER NOT NULL,
    repo TEXT NOT NULL,
    body TEXT NOT NULL,
    created_at TEXT,
    UNIQUE(repo, issue_number, id)
);
`

// createPendingIssuesTableSQL defines the schema for pending new issues.
const createPendingIssuesTableSQL = `
CREATE TABLE IF NOT EXISTS pending_issues (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    repo TEXT NOT NULL,
    title TEXT NOT NULL,
    body TEXT,
    labels TEXT,
    created_at TEXT
);
`

// InitDB creates or opens a SQLite database at the given path and initializes the schema.
func InitDB(path string) (*DB, error) <span class="cov8" title="1">{
        conn, err := sql.Open("sqlite", path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Configure connection pool for SQLite.
        // SQLite only supports a single writer, so we limit to one connection
        // to prevent "database is locked" errors under concurrent FUSE operations.
        <span class="cov8" title="1">conn.SetMaxOpenConns(1)
        conn.SetMaxIdleConns(1)
        conn.SetConnMaxLifetime(0)

        // Create the issues table if it doesn't exist
        _, err = conn.Exec(createTableSQL)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to create issues table: %w", err)
        }</span>

        // Create the comments table if it doesn't exist
        <span class="cov8" title="1">_, err = conn.Exec(createCommentsTableSQL)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to create comments table: %w", err)
        }</span>

        // Create the pending_comments table if it doesn't exist
        <span class="cov8" title="1">_, err = conn.Exec(createPendingCommentsTableSQL)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to create pending_comments table: %w", err)
        }</span>

        // Create the pending_issues table if it doesn't exist
        <span class="cov8" title="1">_, err = conn.Exec(createPendingIssuesTableSQL)
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to create pending_issues table: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;DB{
                path: path,
                conn: conn,
        }, nil</span>
}

// Close closes the database connection.
func (db *DB) Close() error <span class="cov8" title="1">{
        if db.conn != nil </span><span class="cov8" title="1">{
                return db.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpsertIssue inserts or updates an issue in the cache.
// Uses INSERT OR REPLACE to handle both insert and update cases.
func (db *DB) UpsertIssue(issue Issue) error <span class="cov8" title="1">{
        // Convert labels slice to JSON string
        labelsJSON, err := json.Marshal(issue.Labels)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal labels: %w", err)
        }</span>

        // Convert dirty bool to int
        <span class="cov8" title="1">dirtyInt := 0
        if issue.Dirty </span><span class="cov8" title="1">{
                dirtyInt = 1
        }</span>

        <span class="cov8" title="1">query := `
                INSERT OR REPLACE INTO issues (
                        number, repo, title, body, state, author, labels,
                        created_at, updated_at, etag, dirty, local_updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        _, err = db.conn.Exec(query,
                issue.Number,
                issue.Repo,
                issue.Title,
                sql.NullString{String: issue.Body, Valid: issue.Body != ""},
                sql.NullString{String: issue.State, Valid: issue.State != ""},
                sql.NullString{String: issue.Author, Valid: issue.Author != ""},
                string(labelsJSON),
                sql.NullString{String: issue.CreatedAt, Valid: issue.CreatedAt != ""},
                sql.NullString{String: issue.UpdatedAt, Valid: issue.UpdatedAt != ""},
                sql.NullString{String: issue.ETag, Valid: issue.ETag != ""},
                dirtyInt,
                sql.NullString{String: issue.LocalUpdatedAt, Valid: issue.LocalUpdatedAt != ""},
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upsert issue: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetIssue retrieves an issue from the cache by repo and number.
func (db *DB) GetIssue(repo string, number int) (*Issue, error) <span class="cov8" title="1">{
        query := `
                SELECT id, number, repo, title, body, state, author, labels,
                       created_at, updated_at, etag, dirty, local_updated_at
                FROM issues
                WHERE repo = ? AND number = ?
        `

        row := db.conn.QueryRow(query, repo, number)
        return scanIssueFrom(row)
}</span>

// ListIssues retrieves all issues for a repository.
func (db *DB) ListIssues(repo string) ([]Issue, error) <span class="cov8" title="1">{
        query := `
                SELECT id, number, repo, title, body, state, author, labels,
                       created_at, updated_at, etag, dirty, local_updated_at
                FROM issues
                WHERE repo = ?
                ORDER BY number ASC
        `

        rows, err := db.conn.Query(query, repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query issues: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        issues := []Issue{}
        for rows.Next() </span><span class="cov8" title="1">{
                issue, err := scanIssueFrom(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">issues = append(issues, *issue)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating rows: %w", err)
        }</span>

        <span class="cov8" title="1">return issues, nil</span>
}

// MarkDirty marks an issue as having local changes by updating the title and/or body,
// setting dirty=1, and updating local_updated_at to the current time.
// Pass nil for newTitle or newBody to leave that field unchanged.
func (db *DB) MarkDirty(repo string, number int, newTitle, newBody *string) error <span class="cov8" title="1">{
        localUpdatedAt := time.Now().UTC().Format(time.RFC3339)

        // Build dynamic query based on which fields are being updated
        var setClauses []string
        var args []interface{}

        if newTitle != nil </span><span class="cov0" title="0">{
                setClauses = append(setClauses, "title = ?")
                args = append(args, *newTitle)
        }</span>
        <span class="cov8" title="1">if newBody != nil </span><span class="cov8" title="1">{
                setClauses = append(setClauses, "body = ?")
                args = append(args, *newBody)
        }</span>

        // Always set dirty and local_updated_at
        <span class="cov8" title="1">setClauses = append(setClauses, "dirty = 1", "local_updated_at = ?")
        args = append(args, localUpdatedAt, repo, number)

        query := fmt.Sprintf(`
                UPDATE issues
                SET %s
                WHERE repo = ? AND number = ?
        `, strings.Join(setClauses, ", "))

        result, err := db.conn.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark issue dirty: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no issue found with repo=%s and number=%d", repo, number)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetDirtyIssues retrieves all issues with dirty=1 for a repository.
func (db *DB) GetDirtyIssues(repo string) ([]Issue, error) <span class="cov8" title="1">{
        query := `
                SELECT id, number, repo, title, body, state, author, labels,
                       created_at, updated_at, etag, dirty, local_updated_at
                FROM issues
                WHERE repo = ? AND dirty = 1
                ORDER BY number ASC
        `

        rows, err := db.conn.Query(query, repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query dirty issues: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        issues := []Issue{}
        for rows.Next() </span><span class="cov8" title="1">{
                issue, err := scanIssueFrom(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">issues = append(issues, *issue)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating rows: %w", err)
        }</span>

        <span class="cov8" title="1">return issues, nil</span>
}

// ClearDirty clears the dirty flag for an issue after successful sync.
func (db *DB) ClearDirty(repo string, number int) error <span class="cov8" title="1">{
        query := `
                UPDATE issues
                SET dirty = 0
                WHERE repo = ? AND number = ?
        `

        result, err := db.conn.Exec(query, repo, number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear dirty flag: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no issue found with repo=%s and number=%d", repo, number)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// scanner is an interface that both *sql.Row and *sql.Rows implement.
type scanner interface {
        Scan(dest ...interface{}) error
}

// scanIssueFrom scans a row into an Issue struct using the scanner interface.
// This handles both *sql.Row and *sql.Rows.
func scanIssueFrom(s scanner) (*Issue, error) <span class="cov8" title="1">{
        var issue Issue
        var body, state, author, labels, createdAt, updatedAt, etag, localUpdatedAt sql.NullString
        var dirty int

        err := s.Scan(
                &amp;issue.ID,
                &amp;issue.Number,
                &amp;issue.Repo,
                &amp;issue.Title,
                &amp;body,
                &amp;state,
                &amp;author,
                &amp;labels,
                &amp;createdAt,
                &amp;updatedAt,
                &amp;etag,
                &amp;dirty,
                &amp;localUpdatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to scan issue: %w", err)</span>
        }

        // Handle nullable fields
        <span class="cov8" title="1">issue.Body = body.String
        issue.State = state.String
        issue.Author = author.String
        issue.CreatedAt = createdAt.String
        issue.UpdatedAt = updatedAt.String
        issue.ETag = etag.String
        issue.LocalUpdatedAt = localUpdatedAt.String
        issue.Dirty = dirty == 1

        // Parse labels JSON
        if labels.Valid &amp;&amp; labels.String != "" </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(labels.String), &amp;issue.Labels); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal labels: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;issue, nil</span>
}

// UpsertComments inserts or updates comments for an issue in the cache.
// This replaces all existing comments for the issue with the provided comments.
func (db *DB) UpsertComments(repo string, issueNumber int, comments []Comment) error <span class="cov8" title="1">{
        // Start a transaction to ensure atomicity
        tx, err := db.conn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Delete existing comments for this issue
        _, err = tx.Exec("DELETE FROM comments WHERE repo = ? AND issue_number = ?", repo, issueNumber)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete existing comments: %w", err)
        }</span>

        // Insert new comments
        <span class="cov8" title="1">query := `
                INSERT INTO comments (id, issue_number, repo, author, body, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `

        for _, comment := range comments </span><span class="cov8" title="1">{
                _, err = tx.Exec(query,
                        comment.ID,
                        issueNumber,
                        repo,
                        comment.Author,
                        sql.NullString{String: comment.Body, Valid: comment.Body != ""},
                        sql.NullString{String: comment.CreatedAt, Valid: comment.CreatedAt != ""},
                        sql.NullString{String: comment.UpdatedAt, Valid: comment.UpdatedAt != ""},
                )
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to insert comment %d: %w", comment.ID, err)
                }</span>
        }

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetComments retrieves all comments for an issue from the cache.
// Comments are ordered by created_at ascending.
func (db *DB) GetComments(repo string, issueNumber int) ([]Comment, error) <span class="cov8" title="1">{
        query := `
                SELECT id, issue_number, repo, author, body, created_at, updated_at
                FROM comments
                WHERE repo = ? AND issue_number = ?
                ORDER BY created_at ASC
        `

        rows, err := db.conn.Query(query, repo, issueNumber)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query comments: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        comments := []Comment{}
        for rows.Next() </span><span class="cov8" title="1">{
                var comment Comment
                var body, createdAt, updatedAt sql.NullString

                err := rows.Scan(
                        &amp;comment.ID,
                        &amp;comment.IssueNumber,
                        &amp;comment.Repo,
                        &amp;comment.Author,
                        &amp;body,
                        &amp;createdAt,
                        &amp;updatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan comment: %w", err)
                }</span>

                <span class="cov8" title="1">comment.Body = body.String
                comment.CreatedAt = createdAt.String
                comment.UpdatedAt = updatedAt.String

                comments = append(comments, comment)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating comment rows: %w", err)
        }</span>

        <span class="cov8" title="1">return comments, nil</span>
}

// PendingComment represents a new comment waiting to be synced.
type PendingComment struct {
        ID          int64
        IssueNumber int
        Repo        string
        Body        string
        CreatedAt   string
}

// PendingIssue represents a new issue waiting to be synced.
type PendingIssue struct {
        ID        int64
        Repo      string
        Title     string
        Body      string
        Labels    []string
        CreatedAt string
}

// AddPendingComment adds a new pending comment to be synced to GitHub.
func (db *DB) AddPendingComment(repo string, issueNumber int, body string) error <span class="cov0" title="0">{
        createdAt := time.Now().UTC().Format(time.RFC3339)

        query := `
                INSERT INTO pending_comments (issue_number, repo, body, created_at)
                VALUES (?, ?, ?, ?)
        `

        _, err := db.conn.Exec(query, issueNumber, repo, body, createdAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add pending comment: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetPendingComments retrieves all pending comments for a repository.
func (db *DB) GetPendingComments(repo string) ([]PendingComment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, issue_number, repo, body, created_at
                FROM pending_comments
                WHERE repo = ?
                ORDER BY created_at ASC
        `

        rows, err := db.conn.Query(query, repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query pending comments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var comments []PendingComment
        for rows.Next() </span><span class="cov0" title="0">{
                var c PendingComment
                var createdAt sql.NullString

                err := rows.Scan(&amp;c.ID, &amp;c.IssueNumber, &amp;c.Repo, &amp;c.Body, &amp;createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan pending comment: %w", err)
                }</span>
                <span class="cov0" title="0">c.CreatedAt = createdAt.String
                comments = append(comments, c)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating pending comment rows: %w", err)
        }</span>

        <span class="cov0" title="0">return comments, nil</span>
}

// RemovePendingComment removes a pending comment after successful sync.
func (db *DB) RemovePendingComment(id int64) error <span class="cov0" title="0">{
        _, err := db.conn.Exec("DELETE FROM pending_comments WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove pending comment: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MarkCommentDirty marks an existing comment as dirty (edited locally).
func (db *DB) MarkCommentDirty(repo string, commentID int64, newBody string) error <span class="cov0" title="0">{
        query := `
                UPDATE comments
                SET body = ?, dirty = 1
                WHERE repo = ? AND id = ?
        `

        result, err := db.conn.Exec(query, newBody, repo, commentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark comment dirty: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no comment found with repo=%s and id=%d", repo, commentID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DirtyComment represents an edited comment to be synced.
type DirtyComment struct {
        ID          int64
        IssueNumber int
        Repo        string
        Body        string
}

// GetDirtyComments retrieves all comments with dirty=1 for a repository.
func (db *DB) GetDirtyComments(repo string) ([]DirtyComment, error) <span class="cov0" title="0">{
        query := `
                SELECT id, issue_number, repo, body
                FROM comments
                WHERE repo = ? AND dirty = 1
                ORDER BY id ASC
        `

        rows, err := db.conn.Query(query, repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query dirty comments: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var comments []DirtyComment
        for rows.Next() </span><span class="cov0" title="0">{
                var c DirtyComment
                err := rows.Scan(&amp;c.ID, &amp;c.IssueNumber, &amp;c.Repo, &amp;c.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan dirty comment: %w", err)
                }</span>
                <span class="cov0" title="0">comments = append(comments, c)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating dirty comment rows: %w", err)
        }</span>

        <span class="cov0" title="0">return comments, nil</span>
}

// ClearCommentDirty clears the dirty flag for a comment after successful sync.
func (db *DB) ClearCommentDirty(repo string, commentID int64) error <span class="cov0" title="0">{
        query := `
                UPDATE comments
                SET dirty = 0
                WHERE repo = ? AND id = ?
        `

        _, err := db.conn.Exec(query, repo, commentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear comment dirty flag: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddPendingIssue adds a new pending issue to be synced to GitHub.
func (db *DB) AddPendingIssue(repo, title, body string, labels []string) (int64, error) <span class="cov0" title="0">{
        createdAt := time.Now().UTC().Format(time.RFC3339)

        labelsJSON, err := json.Marshal(labels)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal labels: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO pending_issues (repo, title, body, labels, created_at)
                VALUES (?, ?, ?, ?, ?)
        `

        result, err := db.conn.Exec(query, repo, title, body, string(labelsJSON), createdAt)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to add pending issue: %w", err)
        }</span>

        <span class="cov0" title="0">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get last insert id: %w", err)
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

// GetPendingIssues retrieves all pending issues for a repository.
func (db *DB) GetPendingIssues(repo string) ([]PendingIssue, error) <span class="cov0" title="0">{
        query := `
                SELECT id, repo, title, body, labels, created_at
                FROM pending_issues
                WHERE repo = ?
                ORDER BY created_at ASC
        `

        rows, err := db.conn.Query(query, repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query pending issues: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var issues []PendingIssue
        for rows.Next() </span><span class="cov0" title="0">{
                var i PendingIssue
                var body, labels, createdAt sql.NullString

                err := rows.Scan(&amp;i.ID, &amp;i.Repo, &amp;i.Title, &amp;body, &amp;labels, &amp;createdAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan pending issue: %w", err)
                }</span>

                <span class="cov0" title="0">i.Body = body.String
                i.CreatedAt = createdAt.String

                // Parse labels JSON
                if labels.Valid &amp;&amp; labels.String != "" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(labels.String), &amp;i.Labels); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal labels: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">issues = append(issues, i)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating pending issue rows: %w", err)
        }</span>

        <span class="cov0" title="0">return issues, nil</span>
}

// RemovePendingIssue removes a pending issue after successful sync.
func (db *DB) RemovePendingIssue(id int64) error <span class="cov0" title="0">{
        _, err := db.conn.Exec("DELETE FROM pending_issues WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove pending issue: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package fs provides a FUSE filesystem for GitHub issues.
package fs

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "regexp"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/JohanCodinha/ghissues/internal/cache"
        "github.com/JohanCodinha/ghissues/internal/logger"
        "github.com/JohanCodinha/ghissues/internal/md"
        "github.com/hanwen/go-fuse/v2/fs"
        "github.com/hanwen/go-fuse/v2/fuse"
)

const (
        // maxTitleLength is the maximum length for sanitized titles in filenames.
        maxTitleLength = 50
        // maxFileSize is the maximum allowed file size (10MB) to prevent unbounded memory growth.
        maxFileSize = 10 * 1024 * 1024
)

// parseIssueTime parses an RFC3339 timestamp string and returns the time.
// If the timestamp is empty or invalid, it returns the current time as a fallback.
func parseIssueTime(timestamp string) time.Time <span class="cov8" title="1">{
        if timestamp == "" </span><span class="cov8" title="1">{
                return time.Now()
        }</span>
        <span class="cov8" title="1">t, err := time.Parse(time.RFC3339, timestamp)
        if err != nil </span><span class="cov8" title="1">{
                return time.Now()
        }</span>
        <span class="cov8" title="1">return t</span>
}

// filenameRegex matches issue filenames in the format: title[number].md
var filenameRegex = regexp.MustCompile(`^(.+)\[(\d+)\]\.md$`)

// newIssueFilenameRegex matches new issue filenames in the format: title[new].md
var newIssueFilenameRegex = regexp.MustCompile(`^(.+)\[new\]\.md$`)

// sanitizeTitle converts an issue title to a filesystem-safe filename component.
// It lowercases, replaces spaces with dashes, removes special characters,
// and truncates to maxTitleLength characters.
func sanitizeTitle(title string) string <span class="cov8" title="1">{
        // Lowercase
        result := strings.ToLower(title)

        // Replace spaces with dashes
        result = strings.ReplaceAll(result, " ", "-")

        // Remove special characters (keep only alphanumeric and dashes)
        var sb strings.Builder
        for _, r := range result </span><span class="cov8" title="1">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '-' </span><span class="cov8" title="1">{
                        sb.WriteRune(r)
                }</span>
        }
        <span class="cov8" title="1">result = sb.String()

        // Collapse multiple dashes into one
        for strings.Contains(result, "--") </span><span class="cov8" title="1">{
                result = strings.ReplaceAll(result, "--", "-")
        }</span>

        // Trim leading/trailing dashes
        <span class="cov8" title="1">result = strings.Trim(result, "-")

        // Truncate to maxTitleLength
        if len(result) &gt; maxTitleLength </span><span class="cov8" title="1">{
                result = result[:maxTitleLength]
                // Trim trailing dash if truncation left one
                result = strings.TrimSuffix(result, "-")
        }</span>

        // Handle empty result
        <span class="cov8" title="1">if result == "" </span><span class="cov8" title="1">{
                result = "issue"
        }</span>

        <span class="cov8" title="1">return result</span>
}

// makeFilename creates a filename from an issue title and number.
// Format: sanitized-title[number].md
func makeFilename(title string, number int) string <span class="cov8" title="1">{
        sanitized := sanitizeTitle(title)
        return fmt.Sprintf("%s[%d].md", sanitized, number)
}</span>

// parseFilename extracts the issue number from a filename.
// Returns the issue number and true if successful, or 0 and false if the filename doesn't match.
func parseFilename(name string) (int, bool) <span class="cov8" title="1">{
        matches := filenameRegex.FindStringSubmatch(name)
        if matches == nil || len(matches) &lt; 3 </span><span class="cov8" title="1">{
                return 0, false
        }</span>

        <span class="cov8" title="1">var number int
        _, err := fmt.Sscanf(matches[2], "%d", &amp;number)
        if err != nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>

        <span class="cov8" title="1">return number, true</span>
}

// parseNewIssueFilename checks if a filename is for a new issue (title[new].md format).
// Returns the title portion and true if it matches, or empty string and false if not.
func parseNewIssueFilename(name string) (string, bool) <span class="cov8" title="1">{
        matches := newIssueFilenameRegex.FindStringSubmatch(name)
        if matches == nil || len(matches) &lt; 2 </span><span class="cov8" title="1">{
                return "", false
        }</span>
        <span class="cov8" title="1">return matches[1], true</span>
}

// unsanitizeTitle converts a sanitized filename back to a human-readable title.
// It replaces dashes with spaces and capitalizes each word.
func unsanitizeTitle(sanitized string) string <span class="cov8" title="1">{
        // Replace dashes with spaces
        title := strings.ReplaceAll(sanitized, "-", " ")
        // Capitalize first letter of each word
        words := strings.Fields(title)
        for i, word := range words </span><span class="cov8" title="1">{
                if len(word) &gt; 0 </span><span class="cov8" title="1">{
                        words[i] = strings.ToUpper(string(word[0])) + word[1:]
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(words, " ")</span>
}

// FS represents the FUSE filesystem for GitHub issues.
type FS struct {
        cache      *cache.DB
        repo       string
        mountpoint string
        server     *fuse.Server
        onDirty    func() // called when an issue is marked dirty
}

// NewFS creates a new FUSE filesystem instance.
// The onDirty callback is called whenever an issue is marked dirty in the cache.
// Pass nil if no callback is needed.
func NewFS(cacheDB *cache.DB, repo, mountpoint string, onDirty func()) *FS <span class="cov8" title="1">{
        return &amp;FS{
                cache:      cacheDB,
                repo:       repo,
                mountpoint: mountpoint,
                onDirty:    onDirty,
        }
}</span>

// Mount starts the FUSE server and blocks until unmounted.
// It sets up signal handlers for graceful shutdown on SIGINT/SIGTERM.
func (f *FS) Mount() error <span class="cov0" title="0">{
        // Create the root node
        root := &amp;rootNode{
                cache:   f.cache,
                repo:    f.repo,
                onDirty: f.onDirty,
        }

        // Create FUSE server options
        opts := &amp;fs.Options{
                MountOptions: fuse.MountOptions{
                        Debug:      false,
                        FsName:     "ghissues",
                        Name:       "ghissues",
                        AllowOther: false,
                },
                // Set UID and GID to current user
                UID: uint32(os.Getuid()),
                GID: uint32(os.Getgid()),
        }

        // Mount the filesystem
        server, err := fs.Mount(f.mountpoint, root, opts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mount FUSE filesystem: %w", err)
        }</span>
        <span class="cov0" title="0">f.server = server

        // Set up signal handler for graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        // Handle signals in a goroutine
        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                f.Unmount()
        }</span>()

        // Wait until the server is unmounted
        <span class="cov0" title="0">server.Wait()

        return nil</span>
}

// Unmount stops the FUSE server gracefully.
func (f *FS) Unmount() error <span class="cov8" title="1">{
        if f.server != nil </span><span class="cov0" title="0">{
                return f.server.Unmount()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// rootNode represents the root directory of the filesystem.
// It implements fs.InodeEmbedder and fs.NodeReaddirer.
type rootNode struct {
        fs.Inode
        cache   *cache.DB
        repo    string
        onDirty func()
}

var _ = (fs.NodeReaddirer)((*rootNode)(nil))
var _ = (fs.NodeLookuper)((*rootNode)(nil))
var _ = (fs.NodeCreater)((*rootNode)(nil))
var _ = (fs.NodeUnlinker)((*rootNode)(nil))
var _ = (fs.NodeRenamer)((*rootNode)(nil))

// Unlink rejects file deletion - issues cannot be deleted via the filesystem.
func (r *rootNode) Unlink(ctx context.Context, name string) syscall.Errno <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

// Rename rejects file renaming - issues cannot be renamed via the filesystem.
func (r *rootNode) Rename(ctx context.Context, name string, newParent fs.InodeEmbedder, newName string, flags uint32) syscall.Errno <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

// Readdir returns the list of issue files in the directory.
func (r *rootNode) Readdir(ctx context.Context) (fs.DirStream, syscall.Errno) <span class="cov8" title="1">{
        issues, err := r.cache.ListIssues(r.repo)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("fuse: failed to list issues for repo %s: %v", r.repo, err)
                return nil, syscall.EIO
        }</span>

        <span class="cov8" title="1">entries := make([]fuse.DirEntry, 0, len(issues))
        for _, issue := range issues </span><span class="cov8" title="1">{
                filename := makeFilename(issue.Title, issue.Number)
                entries = append(entries, fuse.DirEntry{
                        Name: filename,
                        Ino:  uint64(issue.Number),
                        Mode: fuse.S_IFREG,
                })
        }</span>

        <span class="cov8" title="1">return fs.NewListDirStream(entries), 0</span>
}

// Lookup finds a file by name and returns its inode.
func (r *rootNode) Lookup(ctx context.Context, name string, out *fuse.EntryOut) (*fs.Inode, syscall.Errno) <span class="cov8" title="1">{
        // Parse the filename to get the issue number
        number, ok := parseFilename(name)
        if !ok </span><span class="cov8" title="1">{
                return nil, syscall.ENOENT
        }</span>

        // Get the issue from the cache
        <span class="cov8" title="1">issue, err := r.cache.GetIssue(r.repo, number)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("fuse: failed to get issue #%d from cache: %v", number, err)
                return nil, syscall.EIO
        }</span>
        <span class="cov8" title="1">if issue == nil </span><span class="cov8" title="1">{
                return nil, syscall.ENOENT
        }</span>

        // Get comments from the cache
        <span class="cov0" title="0">comments, err := r.cache.GetComments(r.repo, number)
        if err != nil </span><span class="cov0" title="0">{
                // Log but continue with empty comments - issue content is more important
                logger.Debug("fuse: failed to get comments for issue #%d: %v", number, err)
                comments = []cache.Comment{}
        }</span>

        // Generate markdown content to get file size
        <span class="cov0" title="0">content := md.ToMarkdown(issue, comments)

        // Set up attributes
        out.Mode = 0644
        out.Size = uint64(len(content))
        out.Ino = uint64(issue.Number)

        // Set times from issue timestamps
        mtime := parseIssueTime(issue.UpdatedAt)
        ctime := parseIssueTime(issue.CreatedAt)
        out.SetTimes(&amp;mtime, &amp;mtime, &amp;ctime)

        // Create the file node
        fileNode := &amp;issueFileNode{
                cache:   r.cache,
                repo:    r.repo,
                number:  issue.Number,
                onDirty: r.onDirty,
        }

        // Create a stable inode using the issue number
        stable := fs.StableAttr{
                Mode: fuse.S_IFREG,
                Ino:  uint64(issue.Number),
        }

        child := r.NewInode(ctx, fileNode, stable)
        return child, 0</span>
}

// Create creates a new file for a new issue.
// The filename must be in the format: title[new].md
func (r *rootNode) Create(ctx context.Context, name string, flags uint32, mode uint32, out *fuse.EntryOut) (*fs.Inode, fs.FileHandle, uint32, syscall.Errno) <span class="cov0" title="0">{
        // Check if this is a new issue file
        titlePart, ok := parseNewIssueFilename(name)
        if !ok </span><span class="cov0" title="0">{
                // Not a valid new issue filename
                return nil, nil, 0, syscall.EINVAL
        }</span>

        // Convert sanitized title back to a readable title
        <span class="cov0" title="0">title := unsanitizeTitle(titlePart)

        // Create a new issue file node
        // We use a negative number to indicate a pending issue (not yet created on GitHub)
        pendingID := -int(time.Now().UnixNano() % 1000000) // Unique negative ID

        fileNode := &amp;newIssueFileNode{
                cache:   r.cache,
                repo:    r.repo,
                title:   title,
                onDirty: r.onDirty,
        }

        // Create the inode with a unique ID
        stable := fs.StableAttr{
                Mode: fuse.S_IFREG,
                Ino:  uint64(uint32(pendingID) + 0x80000000), // High bit to avoid collision
        }

        child := r.NewInode(ctx, fileNode, stable)

        // Generate initial content template
        template := fmt.Sprintf(`---
repo: %s
state: open
labels: []
---

# %s

## Body

`, r.repo, title)

        handle := &amp;newIssueFileHandle{
                cache:   r.cache,
                repo:    r.repo,
                title:   title,
                buffer:  []byte(template),
                dirty:   true,
                onDirty: r.onDirty,
        }

        // Set file attributes
        out.Mode = 0644
        out.Size = uint64(len(template))
        now := time.Now()
        out.SetTimes(&amp;now, &amp;now, &amp;now)

        return child, handle, fuse.FOPEN_DIRECT_IO, 0</span>
}

// newIssueFileNode represents a new issue file that hasn't been created on GitHub yet.
type newIssueFileNode struct {
        fs.Inode
        cache   *cache.DB
        repo    string
        title   string
        onDirty func()
}

var _ = (fs.NodeGetattrer)((*newIssueFileNode)(nil))
var _ = (fs.NodeOpener)((*newIssueFileNode)(nil))
var _ = (fs.NodeReader)((*newIssueFileNode)(nil))
var _ = (fs.NodeWriter)((*newIssueFileNode)(nil))
var _ = (fs.NodeFlusher)((*newIssueFileNode)(nil))
var _ = (fs.NodeSetattrer)((*newIssueFileNode)(nil))

// Getattr returns file attributes for a new issue file.
func (f *newIssueFileNode) Getattr(ctx context.Context, fh fs.FileHandle, out *fuse.AttrOut) syscall.Errno <span class="cov8" title="1">{
        // New issue file - return minimal attributes
        out.Mode = 0644
        out.Size = 0
        now := time.Now()
        out.SetTimes(&amp;now, &amp;now, &amp;now)
        return 0
}</span>

// Setattr handles attribute changes for a new issue file.
func (f *newIssueFileNode) Setattr(ctx context.Context, fh fs.FileHandle, in *fuse.SetAttrIn, out *fuse.AttrOut) syscall.Errno <span class="cov8" title="1">{
        if handle, ok := fh.(*newIssueFileHandle); ok </span><span class="cov8" title="1">{
                if sz, ok := in.GetSize(); ok </span><span class="cov8" title="1">{
                        handle.mu.Lock()
                        if sz == 0 </span><span class="cov8" title="1">{
                                handle.buffer = []byte{}
                        }</span> else<span class="cov8" title="1"> if int(sz) &lt; len(handle.buffer) </span><span class="cov8" title="1">{
                                handle.buffer = handle.buffer[:sz]
                        }</span>
                        <span class="cov8" title="1">handle.dirty = true
                        out.Size = uint64(len(handle.buffer))
                        handle.mu.Unlock()</span>
                }
        }

        <span class="cov8" title="1">out.Mode = 0644
        now := time.Now()
        out.SetTimes(&amp;now, &amp;now, &amp;now)
        return 0</span>
}

// Open opens a new issue file.
func (f *newIssueFileNode) Open(ctx context.Context, flags uint32) (fs.FileHandle, uint32, syscall.Errno) <span class="cov8" title="1">{
        // Generate initial template
        template := fmt.Sprintf(`---
repo: %s
state: open
labels: []
---

# %s

## Body

`, f.repo, f.title)

        handle := &amp;newIssueFileHandle{
                cache:   f.cache,
                repo:    f.repo,
                title:   f.title,
                buffer:  []byte(template),
                dirty:   false,
                onDirty: f.onDirty,
        }

        return handle, fuse.FOPEN_DIRECT_IO, 0
}</span>

// Read reads from a new issue file.
func (f *newIssueFileNode) Read(ctx context.Context, fh fs.FileHandle, dest []byte, off int64) (fuse.ReadResult, syscall.Errno) <span class="cov8" title="1">{
        handle, ok := fh.(*newIssueFileHandle)
        if !ok </span><span class="cov8" title="1">{
                return nil, syscall.EBADF
        }</span>

        <span class="cov8" title="1">handle.mu.Lock()
        defer handle.mu.Unlock()

        if off &gt;= int64(len(handle.buffer)) </span><span class="cov8" title="1">{
                return fuse.ReadResultData(nil), 0
        }</span>

        <span class="cov8" title="1">end := off + int64(len(dest))
        if end &gt; int64(len(handle.buffer)) </span><span class="cov8" title="1">{
                end = int64(len(handle.buffer))
        }</span>

        <span class="cov8" title="1">return fuse.ReadResultData(handle.buffer[off:end]), 0</span>
}

// Write writes to a new issue file.
func (f *newIssueFileNode) Write(ctx context.Context, fh fs.FileHandle, data []byte, off int64) (uint32, syscall.Errno) <span class="cov8" title="1">{
        handle, ok := fh.(*newIssueFileHandle)
        if !ok </span><span class="cov8" title="1">{
                return 0, syscall.EBADF
        }</span>

        <span class="cov8" title="1">handle.mu.Lock()
        defer handle.mu.Unlock()

        endPos := int(off) + len(data)
        if endPos &gt; maxFileSize </span><span class="cov8" title="1">{
                return 0, syscall.EFBIG
        }</span>

        <span class="cov8" title="1">if endPos &gt; len(handle.buffer) </span><span class="cov8" title="1">{
                newBuf := make([]byte, endPos)
                copy(newBuf, handle.buffer)
                handle.buffer = newBuf
        }</span>

        <span class="cov8" title="1">copy(handle.buffer[off:], data)
        handle.dirty = true

        return uint32(len(data)), 0</span>
}

// Flush is called when a new issue file is closed.
func (f *newIssueFileNode) Flush(ctx context.Context, fh fs.FileHandle) syscall.Errno <span class="cov8" title="1">{
        handle, ok := fh.(*newIssueFileHandle)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">handle.mu.Lock()
        defer handle.mu.Unlock()

        if !handle.dirty </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Parse the content
        <span class="cov8" title="1">content := string(handle.buffer)
        parsed, err := md.FromMarkdown(content)
        if err != nil </span><span class="cov8" title="1">{
                logger.Warn("failed to parse new issue markdown: %v", err)
                return syscall.EIO
        }</span>

        // Extract labels from frontmatter (if any)
        // For now, we don't parse labels from frontmatter (would need to extend ParsedIssue)
        // Just use empty labels
        <span class="cov8" title="1">var labels []string

        // Get title and body from parsed content
        title := parsed.Title
        if title == "" </span><span class="cov8" title="1">{
                title = f.title // Fallback to filename-derived title
        }</span>
        <span class="cov8" title="1">body := parsed.Body

        // Add to pending issues
        _, err = f.cache.AddPendingIssue(f.repo, title, body, labels)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("failed to add pending issue: %v", err)
                return syscall.EIO
        }</span>

        // Trigger sync
        <span class="cov8" title="1">if f.onDirty != nil </span><span class="cov8" title="1">{
                f.onDirty()
        }</span>

        <span class="cov8" title="1">handle.dirty = false
        return 0</span>
}

// newIssueFileHandle represents an open file handle for a new issue.
type newIssueFileHandle struct {
        cache   *cache.DB
        repo    string
        title   string
        buffer  []byte
        dirty   bool
        onDirty func()
        mu      sync.Mutex
}

var _ = (fs.FileHandle)((*newIssueFileHandle)(nil))

// issueFileNode represents a single issue file.
type issueFileNode struct {
        fs.Inode
        cache   *cache.DB
        repo    string
        number  int
        onDirty func()
}

var _ = (fs.NodeGetattrer)((*issueFileNode)(nil))
var _ = (fs.NodeOpener)((*issueFileNode)(nil))
var _ = (fs.NodeReader)((*issueFileNode)(nil))
var _ = (fs.NodeWriter)((*issueFileNode)(nil))
var _ = (fs.NodeFlusher)((*issueFileNode)(nil))
var _ = (fs.NodeSetattrer)((*issueFileNode)(nil))

// Getattr returns file attributes.
func (f *issueFileNode) Getattr(ctx context.Context, fh fs.FileHandle, out *fuse.AttrOut) syscall.Errno <span class="cov8" title="1">{
        issue, err := f.cache.GetIssue(f.repo, f.number)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("fuse: Getattr failed to get issue #%d: %v", f.number, err)
                return syscall.EIO
        }</span>
        <span class="cov8" title="1">if issue == nil </span><span class="cov8" title="1">{
                logger.Warn("fuse: Getattr issue #%d not found in cache", f.number)
                return syscall.EIO
        }</span>

        // Get comments from the cache
        <span class="cov8" title="1">comments, err := f.cache.GetComments(f.repo, f.number)
        if err != nil </span><span class="cov0" title="0">{
                // Log but continue with empty comments - issue content is more important
                logger.Debug("fuse: Getattr failed to get comments for issue #%d: %v", f.number, err)
                comments = []cache.Comment{}
        }</span>

        <span class="cov8" title="1">content := md.ToMarkdown(issue, comments)

        out.Mode = 0644
        out.Size = uint64(len(content))
        out.Ino = uint64(f.number)

        // Set times from issue timestamps
        mtime := parseIssueTime(issue.UpdatedAt)
        ctime := parseIssueTime(issue.CreatedAt)
        out.SetTimes(&amp;mtime, &amp;mtime, &amp;ctime)

        return 0</span>
}

// Setattr handles attribute changes (e.g., truncate).
func (f *issueFileNode) Setattr(ctx context.Context, fh fs.FileHandle, in *fuse.SetAttrIn, out *fuse.AttrOut) syscall.Errno <span class="cov8" title="1">{
        // Handle truncate if requested
        if sz, ok := in.GetSize(); ok </span><span class="cov8" title="1">{
                // If there's an open file handle, update its buffer and report the new size
                if handle, ok := fh.(*issueFileHandle); ok </span><span class="cov8" title="1">{
                        handle.mu.Lock()
                        if sz == 0 </span><span class="cov8" title="1">{
                                handle.buffer = []byte{}
                        }</span> else<span class="cov8" title="1"> if int(sz) &lt; len(handle.buffer) </span><span class="cov8" title="1">{
                                handle.buffer = handle.buffer[:sz]
                        }</span>
                        <span class="cov8" title="1">handle.dirty = true
                        // Use the buffer size we just set, not a cache lookup
                        newSize := uint64(len(handle.buffer))
                        handle.mu.Unlock()

                        out.Mode = 0644
                        out.Ino = uint64(f.number)
                        out.Size = newSize

                        now := time.Now()
                        out.SetTimes(&amp;now, &amp;now, &amp;now)
                        return 0</span>
                }

                // No file handle - use the requested size directly
                <span class="cov8" title="1">out.Mode = 0644
                out.Ino = uint64(f.number)
                out.Size = sz

                now := time.Now()
                out.SetTimes(&amp;now, &amp;now, &amp;now)
                return 0</span>
        }

        // No truncate requested - get current size from cache
        <span class="cov8" title="1">issue, err := f.cache.GetIssue(f.repo, f.number)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("fuse: Setattr failed to get issue #%d: %v", f.number, err)
                return syscall.EIO
        }</span>
        <span class="cov8" title="1">if issue == nil </span><span class="cov0" title="0">{
                logger.Warn("fuse: Setattr issue #%d not found in cache", f.number)
                return syscall.EIO
        }</span>

        <span class="cov8" title="1">out.Mode = 0644
        out.Ino = uint64(f.number)

        // Set times from issue timestamps
        mtime := parseIssueTime(issue.UpdatedAt)
        ctime := parseIssueTime(issue.CreatedAt)
        out.SetTimes(&amp;mtime, &amp;mtime, &amp;ctime)

        // Get comments from the cache
        comments, err := f.cache.GetComments(f.repo, f.number)
        if err != nil </span><span class="cov0" title="0">{
                // Log but continue with empty comments - issue content is more important
                logger.Debug("fuse: Setattr failed to get comments for issue #%d: %v", f.number, err)
                comments = []cache.Comment{}
        }</span>
        <span class="cov8" title="1">content := md.ToMarkdown(issue, comments)
        out.Size = uint64(len(content))

        return 0</span>
}

// Open opens the file and returns a file handle.
func (f *issueFileNode) Open(ctx context.Context, flags uint32) (fs.FileHandle, uint32, syscall.Errno) <span class="cov8" title="1">{
        // Get the issue from cache
        issue, err := f.cache.GetIssue(f.repo, f.number)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("fuse: Open failed to get issue #%d: %v", f.number, err)
                return nil, 0, syscall.EIO
        }</span>
        <span class="cov8" title="1">if issue == nil </span><span class="cov0" title="0">{
                logger.Warn("fuse: Open issue #%d not found in cache", f.number)
                return nil, 0, syscall.EIO
        }</span>

        // Get comments from the cache
        <span class="cov8" title="1">comments, err := f.cache.GetComments(f.repo, f.number)
        if err != nil </span><span class="cov0" title="0">{
                // Log but continue with empty comments - issue content is more important
                logger.Debug("fuse: Open failed to get comments for issue #%d: %v", f.number, err)
                comments = []cache.Comment{}
        }</span>

        // Generate the content
        <span class="cov8" title="1">content := md.ToMarkdown(issue, comments)

        handle := &amp;issueFileHandle{
                cache:   f.cache,
                repo:    f.repo,
                number:  f.number,
                buffer:  []byte(content),
                dirty:   false,
                onDirty: f.onDirty,
        }

        return handle, fuse.FOPEN_DIRECT_IO, 0</span>
}

// Read reads data from the file.
func (f *issueFileNode) Read(ctx context.Context, fh fs.FileHandle, dest []byte, off int64) (fuse.ReadResult, syscall.Errno) <span class="cov8" title="1">{
        handle, ok := fh.(*issueFileHandle)
        if !ok </span><span class="cov8" title="1">{
                // No handle, read directly from cache
                issue, err := f.cache.GetIssue(f.repo, f.number)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("fuse: Read failed to get issue #%d: %v", f.number, err)
                        return nil, syscall.EIO
                }</span>
                <span class="cov8" title="1">if issue == nil </span><span class="cov0" title="0">{
                        logger.Warn("fuse: Read issue #%d not found in cache", f.number)
                        return nil, syscall.EIO
                }</span>
                // Get comments from the cache
                <span class="cov8" title="1">comments, err := f.cache.GetComments(f.repo, f.number)
                if err != nil </span><span class="cov0" title="0">{
                        // Log but continue with empty comments - issue content is more important
                        logger.Debug("fuse: Read failed to get comments for issue #%d: %v", f.number, err)
                        comments = []cache.Comment{}
                }</span>
                <span class="cov8" title="1">content := md.ToMarkdown(issue, comments)
                if off &gt;= int64(len(content)) </span><span class="cov0" title="0">{
                        return fuse.ReadResultData(nil), 0
                }</span>
                <span class="cov8" title="1">end := off + int64(len(dest))
                if end &gt; int64(len(content)) </span><span class="cov8" title="1">{
                        end = int64(len(content))
                }</span>
                <span class="cov8" title="1">return fuse.ReadResultData([]byte(content[off:end])), 0</span>
        }

        <span class="cov8" title="1">handle.mu.Lock()
        defer handle.mu.Unlock()

        if off &gt;= int64(len(handle.buffer)) </span><span class="cov8" title="1">{
                return fuse.ReadResultData(nil), 0
        }</span>

        <span class="cov8" title="1">end := off + int64(len(dest))
        if end &gt; int64(len(handle.buffer)) </span><span class="cov8" title="1">{
                end = int64(len(handle.buffer))
        }</span>

        <span class="cov8" title="1">return fuse.ReadResultData(handle.buffer[off:end]), 0</span>
}

// Write writes data to the file.
func (f *issueFileNode) Write(ctx context.Context, fh fs.FileHandle, data []byte, off int64) (uint32, syscall.Errno) <span class="cov8" title="1">{
        handle, ok := fh.(*issueFileHandle)
        if !ok </span><span class="cov8" title="1">{
                return 0, syscall.EBADF
        }</span>

        <span class="cov8" title="1">handle.mu.Lock()
        defer handle.mu.Unlock()

        // Check if write would exceed maximum file size
        endPos := int(off) + len(data)
        if endPos &gt; maxFileSize </span><span class="cov8" title="1">{
                return 0, syscall.EFBIG // File too large
        }</span>

        // Extend buffer if necessary
        <span class="cov8" title="1">if endPos &gt; len(handle.buffer) </span><span class="cov8" title="1">{
                newBuf := make([]byte, endPos)
                copy(newBuf, handle.buffer)
                handle.buffer = newBuf
        }</span>

        // Copy data to buffer
        <span class="cov8" title="1">copy(handle.buffer[off:], data)
        handle.dirty = true

        return uint32(len(data)), 0</span>
}

// Flush is called when a file is closed. It saves changes to the cache.
func (f *issueFileNode) Flush(ctx context.Context, fh fs.FileHandle) syscall.Errno <span class="cov8" title="1">{
        handle, ok := fh.(*issueFileHandle)
        if !ok </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">handle.mu.Lock()
        defer handle.mu.Unlock()

        if !handle.dirty </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Parse the content to extract changes
        <span class="cov8" title="1">content := string(handle.buffer)
        parsed, err := md.FromMarkdown(content)
        if err != nil </span><span class="cov8" title="1">{
                // Can't parse the content, don't update
                logger.Warn("failed to parse markdown for issue #%d: %v", f.number, err)
                return syscall.EIO
        }</span>

        // Get the original issue
        <span class="cov8" title="1">original, err := f.cache.GetIssue(f.repo, f.number)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("fuse: Flush failed to get original issue #%d: %v", f.number, err)
                return syscall.EIO
        }</span>
        <span class="cov8" title="1">if original == nil </span><span class="cov0" title="0">{
                logger.Warn("fuse: Flush issue #%d not found in cache", f.number)
                return syscall.EIO
        }</span>

        // Detect changes
        <span class="cov8" title="1">changes := md.DetectChanges(original, parsed)

        // Track if we need to trigger sync
        needsSync := false

        // If title or body changed, mark dirty in cache
        if changes.TitleChanged || changes.BodyChanged </span><span class="cov8" title="1">{
                var titlePtr, bodyPtr *string
                if changes.TitleChanged </span><span class="cov8" title="1">{
                        titlePtr = &amp;changes.NewTitle
                }</span>
                <span class="cov8" title="1">if changes.BodyChanged </span><span class="cov8" title="1">{
                        bodyPtr = &amp;changes.NewBody
                }</span>
                <span class="cov8" title="1">err = f.cache.MarkDirty(f.repo, f.number, titlePtr, bodyPtr)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("fuse: Flush failed to mark issue #%d as dirty: %v", f.number, err)
                        return syscall.EIO
                }</span>
                <span class="cov8" title="1">needsSync = true</span>
        }

        // Handle comment changes
        <span class="cov8" title="1">originalComments, err := f.cache.GetComments(f.repo, f.number)
        if err != nil </span><span class="cov0" title="0">{
                originalComments = []cache.Comment{}
        }</span>

        <span class="cov8" title="1">newComments, editedComments := md.DetectCommentChanges(originalComments, parsed.Comments)

        // Add new comments to pending
        for _, nc := range newComments </span><span class="cov0" title="0">{
                err := f.cache.AddPendingComment(f.repo, f.number, nc.Body)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("failed to add pending comment for issue #%d: %v", f.number, err)
                }</span> else<span class="cov0" title="0"> {
                        needsSync = true
                }</span>
        }

        // Mark edited comments as dirty
        <span class="cov8" title="1">for _, ec := range editedComments </span><span class="cov0" title="0">{
                err := f.cache.MarkCommentDirty(f.repo, ec.ID, ec.NewBody)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("failed to mark comment %d as dirty: %v", ec.ID, err)
                }</span> else<span class="cov0" title="0"> {
                        needsSync = true
                }</span>
        }

        // Trigger sync engine callback if changes were made
        <span class="cov8" title="1">if needsSync &amp;&amp; handle.onDirty != nil </span><span class="cov8" title="1">{
                handle.onDirty()
        }</span>

        <span class="cov8" title="1">handle.dirty = false
        return 0</span>
}

// issueFileHandle represents an open file handle for an issue.
type issueFileHandle struct {
        cache   *cache.DB
        repo    string
        number  int
        buffer  []byte
        dirty   bool
        onDirty func()
        mu      sync.Mutex
}

var _ = (fs.FileHandle)((*issueFileHandle)(nil))
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package gh provides a GitHub API client for interacting with issues.
package gh

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/JohanCodinha/ghissues/internal/logger"
        "gopkg.in/yaml.v3"
)

const (
        apiBaseURL = "https://api.github.com"
)

// Label represents a GitHub issue label.
type Label struct {
        Name  string `json:"name"`
        Color string `json:"color"`
}

// User represents a GitHub user.
type User struct {
        Login string `json:"login"`
}

// Issue represents a GitHub issue.
type Issue struct {
        Number    int       `json:"number"`
        Title     string    `json:"title"`
        Body      string    `json:"body"`
        State     string    `json:"state"`
        Labels    []Label   `json:"labels"`
        User      User      `json:"user"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        ETag      string    `json:"-"` // Not from JSON, set from response header
}

// Comment represents a GitHub issue comment.
type Comment struct {
        ID        int64     `json:"id"`
        User      User      `json:"user"`
        Body      string    `json:"body"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// Client is a GitHub API client.
type Client struct {
        token      string
        baseURL    string
        httpClient *http.Client
}

// ghHostsConfig represents the structure of ~/.config/gh/hosts.yml
type ghHostsConfig map[string]ghHost

type ghHost struct {
        OAuthToken string `yaml:"oauth_token"`
        User       string `yaml:"user"`
}

// New creates a new GitHub API client with the given token.
func New(token string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                token:      token,
                baseURL:    apiBaseURL,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
        }
}</span>

// NewWithBaseURL creates a GitHub API client with a custom base URL (for testing).
func NewWithBaseURL(token, baseURL string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                token:      token,
                baseURL:    baseURL,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
        }
}</span>

// GetToken attempts to get a GitHub token from various sources:
// 1. Run `gh auth token` command (gh CLI with keyring storage)
// 2. Read from ~/.config/gh/hosts.yml (older gh CLI format)
// 3. GITHUB_TOKEN environment variable
func GetToken() (string, error) <span class="cov8" title="1">{
        // Try gh auth token command first (handles keyring storage)
        if token, err := getTokenFromGhCLI(); err == nil &amp;&amp; token != "" </span><span class="cov8" title="1">{
                return token, nil
        }</span>

        // Try reading from gh hosts.yml config (older format)
        <span class="cov0" title="0">if token, err := getTokenFromGhConfig(); err == nil &amp;&amp; token != "" </span><span class="cov0" title="0">{
                return token, nil
        }</span>

        // Fall back to GITHUB_TOKEN env var
        <span class="cov0" title="0">if token := os.Getenv("GITHUB_TOKEN"); token != "" </span><span class="cov0" title="0">{
                return token, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("no GitHub token found: install gh CLI and run 'gh auth login', or set GITHUB_TOKEN env var")</span>
}

// getTokenFromGhCLI runs `gh auth token` to get the token from the gh CLI.
func getTokenFromGhCLI() (string, error) <span class="cov8" title="1">{
        cmd := exec.Command("gh", "auth", "token")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("gh auth token failed: %w", err)
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(string(output)), nil</span>
}

// getTokenFromGhConfig reads the token from ~/.config/gh/hosts.yml.
func getTokenFromGhConfig() (string, error) <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov0" title="0">configPath := filepath.Join(homeDir, ".config", "gh", "hosts.yml")
        return getTokenFromGhConfigPath(configPath)</span>
}

// getTokenFromGhConfigPath reads the token from the specified hosts.yml path.
// This is split out from getTokenFromGhConfig for testability.
func getTokenFromGhConfigPath(configPath string) (string, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to read gh config: %w", err)
        }</span>

        <span class="cov8" title="1">var config ghHostsConfig
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to parse gh config: %w", err)
        }</span>

        // Look for github.com host
        <span class="cov8" title="1">if host, ok := config["github.com"]; ok </span><span class="cov8" title="1">{
                if host.OAuthToken != "" </span><span class="cov8" title="1">{
                        return host.OAuthToken, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("no oauth_token found in gh config")</span>
}

// doRequest performs an HTTP request with authentication and returns the response.
func (c *Client) doRequest(method, url string, body io.Reader) (*http.Response, error) <span class="cov8" title="1">{
        req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+c.token)
        req.Header.Set("Accept", "application/vnd.github+json")
        req.Header.Set("X-GitHub-Api-Version", "2022-11-28")

        if body != nil </span><span class="cov8" title="1">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

// checkRateLimit logs rate limit information from response headers.
func checkRateLimit(resp *http.Response) <span class="cov8" title="1">{
        remaining := resp.Header.Get("X-RateLimit-Remaining")
        reset := resp.Header.Get("X-RateLimit-Reset")

        if remaining == "0" &amp;&amp; reset != "" </span><span class="cov8" title="1">{
                resetTime, err := strconv.ParseInt(reset, 10, 64)
                if err == nil </span><span class="cov8" title="1">{
                        resetAt := time.Unix(resetTime, 0)
                        logger.Warn("GitHub API rate limit exceeded. Resets at %s", resetAt.Format(time.RFC3339))
                }</span>
        }
}

// ListIssues fetches all open issues from the repository.
// Handles pagination automatically.
func (c *Client) ListIssues(owner, repo string) ([]Issue, error) <span class="cov8" title="1">{
        var allIssues []Issue
        url := fmt.Sprintf("%s/repos/%s/%s/issues?state=all&amp;per_page=100", c.baseURL, owner, repo)

        for url != "" </span><span class="cov8" title="1">{
                resp, err := c.doRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to list issues for %s/%s: %w", owner, repo, err)
                }</span>

                <span class="cov8" title="1">checkRateLimit(resp)

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        body, _ := io.ReadAll(resp.Body)
                        resp.Body.Close()
                        return nil, fmt.Errorf("failed to list issues for %s/%s: API error %s - %s", owner, repo, resp.Status, string(body))
                }</span>

                <span class="cov8" title="1">var issues []Issue
                if err := json.NewDecoder(resp.Body).Decode(&amp;issues); err != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        return nil, fmt.Errorf("failed to decode issues response for %s/%s: %w", owner, repo, err)
                }</span>

                // Parse Link header for pagination before closing
                <span class="cov8" title="1">url = getNextPageURL(resp.Header.Get("Link"))

                // Close response body immediately after reading
                resp.Body.Close()

                allIssues = append(allIssues, issues...)</span>
        }

        <span class="cov8" title="1">return allIssues, nil</span>
}

// getNextPageURL extracts the next page URL from the Link header.
// Link header format: &lt;url&gt;; rel="next", &lt;url&gt;; rel="last"
func getNextPageURL(linkHeader string) string <span class="cov8" title="1">{
        if linkHeader == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Match &lt;url&gt;; rel="next"
        <span class="cov8" title="1">re := regexp.MustCompile(`&lt;([^&gt;]+)&gt;;\s*rel="next"`)
        matches := re.FindStringSubmatch(linkHeader)
        if len(matches) &gt;= 2 </span><span class="cov8" title="1">{
                return matches[1]
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// GetIssue fetches a single issue by number.
// Returns the issue, the ETag header value, and any error.
func (c *Client) GetIssue(owner, repo string, number int) (*Issue, string, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repos/%s/%s/issues/%d", c.baseURL, owner, repo, number)

        resp, err := c.doRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get issue #%d for %s/%s: %w", number, owner, repo, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        checkRateLimit(resp)

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, "", fmt.Errorf("failed to get issue #%d for %s/%s: API error %s - %s", number, owner, repo, resp.Status, string(body))
        }</span>

        <span class="cov8" title="1">var issue Issue
        if err := json.NewDecoder(resp.Body).Decode(&amp;issue); err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to decode issue #%d response for %s/%s: %w", number, owner, repo, err)
        }</span>

        <span class="cov8" title="1">etag := resp.Header.Get("ETag")
        issue.ETag = etag

        return &amp;issue, etag, nil</span>
}

// UpdateIssue updates an issue's title and/or body.
// Pass nil for title or body to leave that field unchanged.
func (c *Client) UpdateIssue(owner, repo string, number int, title, body *string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repos/%s/%s/issues/%d", c.baseURL, owner, repo, number)

        payload := make(map[string]string)
        if title != nil </span><span class="cov0" title="0">{
                payload["title"] = *title
        }</span>
        <span class="cov8" title="1">if body != nil </span><span class="cov8" title="1">{
                payload["body"] = *body
        }</span>

        <span class="cov8" title="1">jsonPayload, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal payload: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := c.doRequest("PATCH", url, bytes.NewReader(jsonPayload))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update issue #%d for %s/%s: %w", number, owner, repo, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        checkRateLimit(resp)

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                respBody, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to update issue #%d for %s/%s: API error %s - %s", number, owner, repo, resp.Status, string(respBody))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListComments fetches all comments for an issue.
// Handles pagination automatically.
func (c *Client) ListComments(owner, repo string, number int) ([]Comment, error) <span class="cov8" title="1">{
        var allComments []Comment
        url := fmt.Sprintf("%s/repos/%s/%s/issues/%d/comments?per_page=100", c.baseURL, owner, repo, number)

        for url != "" </span><span class="cov8" title="1">{
                resp, err := c.doRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to list comments for issue #%d in %s/%s: %w", number, owner, repo, err)
                }</span>

                <span class="cov8" title="1">checkRateLimit(resp)

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        body, _ := io.ReadAll(resp.Body)
                        resp.Body.Close()
                        return nil, fmt.Errorf("failed to list comments for issue #%d in %s/%s: API error %s - %s", number, owner, repo, resp.Status, string(body))
                }</span>

                <span class="cov8" title="1">var comments []Comment
                if err := json.NewDecoder(resp.Body).Decode(&amp;comments); err != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        return nil, fmt.Errorf("failed to decode comments response for issue #%d in %s/%s: %w", number, owner, repo, err)
                }</span>

                // Parse Link header for pagination before closing
                <span class="cov8" title="1">url = getNextPageURL(resp.Header.Get("Link"))

                // Close response body immediately after reading
                resp.Body.Close()

                allComments = append(allComments, comments...)</span>
        }

        <span class="cov8" title="1">return allComments, nil</span>
}

// CreateComment creates a new comment on an issue.
// Returns the created comment with its assigned ID.
func (c *Client) CreateComment(owner, repo string, number int, body string) (*Comment, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repos/%s/%s/issues/%d/comments", c.baseURL, owner, repo, number)

        payload := map[string]string{"body": body}
        jsonPayload, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal payload: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := c.doRequest("POST", url, bytes.NewReader(jsonPayload))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create comment on issue #%d in %s/%s: %w", number, owner, repo, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        checkRateLimit(resp)

        if resp.StatusCode != http.StatusCreated </span><span class="cov8" title="1">{
                respBody, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("failed to create comment on issue #%d in %s/%s: API error %s - %s", number, owner, repo, resp.Status, string(respBody))
        }</span>

        <span class="cov8" title="1">var comment Comment
        if err := json.NewDecoder(resp.Body).Decode(&amp;comment); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode comment response for issue #%d in %s/%s: %w", number, owner, repo, err)
        }</span>

        <span class="cov8" title="1">return &amp;comment, nil</span>
}

// UpdateComment updates an existing comment.
func (c *Client) UpdateComment(owner, repo string, commentID int64, body string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repos/%s/%s/issues/comments/%d", c.baseURL, owner, repo, commentID)

        payload := map[string]string{"body": body}
        jsonPayload, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal payload: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := c.doRequest("PATCH", url, bytes.NewReader(jsonPayload))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update comment %d in %s/%s: %w", commentID, owner, repo, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        checkRateLimit(resp)

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                respBody, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to update comment %d in %s/%s: API error %s - %s", commentID, owner, repo, resp.Status, string(respBody))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CreateIssue creates a new issue in a repository.
// Returns the created issue with its assigned number.
func (c *Client) CreateIssue(owner, repo, title, body string, labels []string) (*Issue, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repos/%s/%s/issues", c.baseURL, owner, repo)

        payload := map[string]interface{}{
                "title": title,
                "body":  body,
        }
        if len(labels) &gt; 0 </span><span class="cov8" title="1">{
                payload["labels"] = labels
        }</span>

        <span class="cov8" title="1">jsonPayload, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal payload: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := c.doRequest("POST", url, bytes.NewReader(jsonPayload))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create issue in %s/%s: %w", owner, repo, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        checkRateLimit(resp)

        if resp.StatusCode != http.StatusCreated </span><span class="cov8" title="1">{
                respBody, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("failed to create issue in %s/%s: API error %s - %s", owner, repo, resp.Status, string(respBody))
        }</span>

        <span class="cov8" title="1">var issue Issue
        if err := json.NewDecoder(resp.Body).Decode(&amp;issue); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode created issue response for %s/%s: %w", owner, repo, err)
        }</span>

        <span class="cov8" title="1">etag := resp.Header.Get("ETag")
        issue.ETag = etag

        return &amp;issue, nil</span>
}

// GetIssueWithEtag fetches an issue using a conditional request with etag.
// Returns (nil, "", nil) on 304 Not Modified.
// Returns (*Issue, newEtag, nil) on 200 OK with new data.
func (c *Client) GetIssueWithEtag(owner, repo string, number int, etag string) (*Issue, string, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repos/%s/%s/issues/%d", c.baseURL, owner, repo, number)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+c.token)
        req.Header.Set("Accept", "application/vnd.github+json")
        req.Header.Set("X-GitHub-Api-Version", "2022-11-28")

        // Add conditional request header
        if etag != "" </span><span class="cov8" title="1">{
                req.Header.Set("If-None-Match", etag)
        }</span>

        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get issue #%d with etag for %s/%s: %w", number, owner, repo, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        checkRateLimit(resp)

        // 304 Not Modified - issue hasn't changed
        if resp.StatusCode == http.StatusNotModified </span><span class="cov8" title="1">{
                return nil, "", nil
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, "", fmt.Errorf("failed to get issue #%d with etag for %s/%s: API error %s - %s", number, owner, repo, resp.Status, string(body))
        }</span>

        <span class="cov8" title="1">var issue Issue
        if err := json.NewDecoder(resp.Body).Decode(&amp;issue); err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to decode issue #%d response for %s/%s: %w", number, owner, repo, err)
        }</span>

        <span class="cov8" title="1">newEtag := resp.Header.Get("ETag")
        issue.ETag = newEtag

        return &amp;issue, newEtag, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package gh

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "strconv"
        "strings"
        "sync"
        "time"
)

// MockServer provides a fake GitHub API for testing
type MockServer struct {
        *httptest.Server
        mu       sync.RWMutex
        issues   map[int]*Issue              // issue number -&gt; issue
        comments map[int][]*Comment          // issue number -&gt; comments

        // Pagination settings
        issuesPerPage   int // 0 means return all in one page
        commentsPerPage int // 0 means return all in one page

        // Error simulation
        forceStatusCode int    // If set, return this status code for next request
        forceErrorBody  string // Error body to return with forceStatusCode

        // Counters for ID generation
        nextCommentID int64
        nextIssueNum  int
}

// NewMockServer creates a mock GitHub API server
func NewMockServer() *MockServer <span class="cov8" title="1">{
        m := &amp;MockServer{
                issues:        make(map[int]*Issue),
                comments:      make(map[int][]*Comment),
                nextCommentID: 1000,
                nextIssueNum:  1,
        }

        mux := http.NewServeMux()

        // List issues: GET /repos/{owner}/{repo}/issues
        mux.HandleFunc("/repos/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/repos/"), "/")
                if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                        http.Error(w, "invalid path", http.StatusBadRequest)
                        return
                }</span>

                // /repos/{owner}/{repo}/issues
                <span class="cov8" title="1">if parts[2] == "issues" </span><span class="cov8" title="1">{
                        if len(parts) == 3 </span><span class="cov8" title="1">{
                                // List issues or create issue
                                switch r.Method </span>{
                                case http.MethodGet:<span class="cov8" title="1">
                                        m.handleListIssues(w, r)
                                        return</span>
                                case http.MethodPost:<span class="cov8" title="1">
                                        m.handleCreateIssue(w, r)
                                        return</span>
                                }
                        } else<span class="cov8" title="1"> if len(parts) == 4 </span><span class="cov8" title="1">{
                                // Check if this is the /comments endpoint (for updating comments)
                                if parts[3] == "comments" </span><span class="cov0" title="0">{
                                        // This path shouldn't happen at len==4
                                        http.Error(w, "not found", http.StatusNotFound)
                                        return
                                }</span>
                                // Single issue: /repos/{owner}/{repo}/issues/{number}
                                <span class="cov8" title="1">number, err := strconv.Atoi(parts[3])
                                if err != nil </span><span class="cov0" title="0">{
                                        http.Error(w, "invalid issue number", http.StatusBadRequest)
                                        return
                                }</span>
                                <span class="cov8" title="1">switch r.Method </span>{
                                case http.MethodGet:<span class="cov8" title="1">
                                        m.handleGetIssue(w, r, number)</span>
                                case http.MethodPatch:<span class="cov8" title="1">
                                        m.handleUpdateIssue(w, r, number)</span>
                                default:<span class="cov0" title="0">
                                        http.Error(w, "method not allowed", http.StatusMethodNotAllowed)</span>
                                }
                                <span class="cov8" title="1">return</span>
                        } else<span class="cov8" title="1"> if len(parts) == 5 &amp;&amp; parts[4] == "comments" </span><span class="cov8" title="1">{
                                // /repos/{owner}/{repo}/issues/{number}/comments
                                number, err := strconv.Atoi(parts[3])
                                if err != nil </span><span class="cov0" title="0">{
                                        http.Error(w, "invalid issue number", http.StatusBadRequest)
                                        return
                                }</span>
                                <span class="cov8" title="1">switch r.Method </span>{
                                case http.MethodGet:<span class="cov8" title="1">
                                        m.handleListComments(w, r, number)</span>
                                case http.MethodPost:<span class="cov8" title="1">
                                        m.handleCreateComment(w, r, number)</span>
                                default:<span class="cov0" title="0">
                                        http.Error(w, "method not allowed", http.StatusMethodNotAllowed)</span>
                                }
                                <span class="cov8" title="1">return</span>
                        } else<span class="cov8" title="1"> if len(parts) == 5 &amp;&amp; parts[3] == "comments" </span><span class="cov8" title="1">{
                                // /repos/{owner}/{repo}/issues/comments/{comment_id}
                                commentID, err := strconv.ParseInt(parts[4], 10, 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        http.Error(w, "invalid comment id", http.StatusBadRequest)
                                        return
                                }</span>
                                <span class="cov8" title="1">switch r.Method </span>{
                                case http.MethodPatch:<span class="cov8" title="1">
                                        m.handleUpdateComment(w, r, commentID)</span>
                                default:<span class="cov0" title="0">
                                        http.Error(w, "method not allowed", http.StatusMethodNotAllowed)</span>
                                }
                                <span class="cov8" title="1">return</span>
                        }
                }
                <span class="cov0" title="0">http.Error(w, "not found", http.StatusNotFound)</span>
        })

        <span class="cov8" title="1">m.Server = httptest.NewServer(mux)
        return m</span>
}

// AddIssue adds an issue to the mock server
func (m *MockServer) AddIssue(issue *Issue) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.issues[issue.Number] = issue
}</span>

// GetIssue retrieves an issue (for test assertions)
func (m *MockServer) GetIssue(number int) *Issue <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.issues[number]
}</span>

// Reset clears all issues and comments
func (m *MockServer) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.issues = make(map[int]*Issue)
        m.comments = make(map[int][]*Comment)
}</span>

// AddComment adds a comment to an issue in the mock server
func (m *MockServer) AddComment(issueNumber int, comment *Comment) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.comments[issueNumber] = append(m.comments[issueNumber], comment)
}</span>

// GetComments retrieves comments for an issue (for test assertions)
func (m *MockServer) GetComments(issueNumber int) []*Comment <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.comments[issueNumber]
}</span>

// SetIssuesPerPage sets pagination for issues (0 = no pagination)
func (m *MockServer) SetIssuesPerPage(perPage int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.issuesPerPage = perPage
}</span>

// SetCommentsPerPage sets pagination for comments (0 = no pagination)
func (m *MockServer) SetCommentsPerPage(perPage int) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.commentsPerPage = perPage
}</span>

// SetNextError sets an error to be returned for the next request
func (m *MockServer) SetNextError(statusCode int, body string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.forceStatusCode = statusCode
        m.forceErrorBody = body
}</span>

// clearError clears any forced error (internal use)
func (m *MockServer) clearError() (int, string) <span class="cov8" title="1">{
        code := m.forceStatusCode
        body := m.forceErrorBody
        m.forceStatusCode = 0
        m.forceErrorBody = ""
        return code, body
}</span>

func (m *MockServer) handleListIssues(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        m.mu.Lock()
        // Check for forced error
        if code, body := m.clearError(); code != 0 </span><span class="cov0" title="0">{
                m.mu.Unlock()
                http.Error(w, body, code)
                return
        }</span>

        <span class="cov8" title="1">issues := make([]*Issue, 0, len(m.issues))
        for _, issue := range m.issues </span><span class="cov8" title="1">{
                issues = append(issues, issue)
        }</span>
        <span class="cov8" title="1">perPage := m.issuesPerPage
        m.mu.Unlock()

        // Sort issues by number for consistent pagination
        sortIssuesByNumber(issues)

        // Handle pagination
        if perPage &gt; 0 </span><span class="cov8" title="1">{
                page := 1
                if p := r.URL.Query().Get("page"); p != "" </span><span class="cov8" title="1">{
                        page, _ = strconv.Atoi(p)
                        if page &lt; 1 </span><span class="cov0" title="0">{
                                page = 1
                        }</span>
                }

                <span class="cov8" title="1">start := (page - 1) * perPage
                end := start + perPage

                if start &gt;= len(issues) </span><span class="cov0" title="0">{
                        issues = []*Issue{}
                }</span> else<span class="cov8" title="1"> {
                        if end &gt; len(issues) </span><span class="cov0" title="0">{
                                end = len(issues)
                        }</span>
                        <span class="cov8" title="1">issues = issues[start:end]

                        // Add Link header for next page if there are more
                        totalPages := (len(m.issues) + perPage - 1) / perPage
                        if page &lt; totalPages </span><span class="cov8" title="1">{
                                nextURL := fmt.Sprintf("%s%s?page=%d", m.Server.URL, r.URL.Path, page+1)
                                w.Header().Set("Link", fmt.Sprintf(`&lt;%s&gt;; rel="next"`, nextURL))
                        }</span>
                }
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(issues)</span>
}

// sortIssuesByNumber sorts issues by their number (ascending)
func sortIssuesByNumber(issues []*Issue) <span class="cov8" title="1">{
        for i := 0; i &lt; len(issues)-1; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(issues); j++ </span><span class="cov8" title="1">{
                        if issues[i].Number &gt; issues[j].Number </span><span class="cov8" title="1">{
                                issues[i], issues[j] = issues[j], issues[i]
                        }</span>
                }
        }
}

func (m *MockServer) handleGetIssue(w http.ResponseWriter, r *http.Request, number int) <span class="cov8" title="1">{
        m.mu.RLock()
        issue, ok := m.issues[number]
        m.mu.RUnlock()

        if !ok </span><span class="cov8" title="1">{
                http.Error(w, "not found", http.StatusNotFound)
                return
        }</span>

        // Handle conditional request (If-None-Match)
        <span class="cov8" title="1">if etag := r.Header.Get("If-None-Match"); etag != "" &amp;&amp; etag == issue.ETag </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNotModified)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.Header().Set("ETag", issue.ETag)
        json.NewEncoder(w).Encode(issue)</span>
}

func (m *MockServer) handleUpdateIssue(w http.ResponseWriter, r *http.Request, number int) <span class="cov8" title="1">{
        m.mu.Lock()
        // Check for forced error first
        if code, body := m.clearError(); code != 0 </span><span class="cov8" title="1">{
                m.mu.Unlock()
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(code)
                w.Write([]byte(body))
                return
        }</span>

        <span class="cov8" title="1">issue, ok := m.issues[number]
        if !ok </span><span class="cov8" title="1">{
                m.mu.Unlock()
                http.Error(w, `{"message":"Not Found"}`, http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">var update struct {
                Title string `json:"title,omitempty"`
                Body  string `json:"body,omitempty"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;update); err != nil </span><span class="cov0" title="0">{
                m.mu.Unlock()
                http.Error(w, "invalid json", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if update.Title != "" </span><span class="cov0" title="0">{
                issue.Title = update.Title
        }</span>
        <span class="cov8" title="1">if update.Body != "" </span><span class="cov8" title="1">{
                issue.Body = update.Body
        }</span>
        <span class="cov8" title="1">issue.UpdatedAt = time.Now().UTC()
        issue.ETag = `"` + strconv.FormatInt(time.Now().UnixNano(), 16) + `"`
        m.mu.Unlock()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(issue)</span>
}

func (m *MockServer) handleListComments(w http.ResponseWriter, r *http.Request, number int) <span class="cov8" title="1">{
        m.mu.Lock()
        // Check for forced error
        if code, body := m.clearError(); code != 0 </span><span class="cov0" title="0">{
                m.mu.Unlock()
                http.Error(w, body, code)
                return
        }</span>

        <span class="cov8" title="1">comments := m.comments[number]
        if comments == nil </span><span class="cov8" title="1">{
                comments = []*Comment{}
        }</span>
        <span class="cov8" title="1">perPage := m.commentsPerPage
        totalComments := len(comments)
        m.mu.Unlock()

        // Handle pagination
        if perPage &gt; 0 &amp;&amp; len(comments) &gt; 0 </span><span class="cov8" title="1">{
                page := 1
                if p := r.URL.Query().Get("page"); p != "" </span><span class="cov8" title="1">{
                        page, _ = strconv.Atoi(p)
                        if page &lt; 1 </span><span class="cov0" title="0">{
                                page = 1
                        }</span>
                }

                <span class="cov8" title="1">start := (page - 1) * perPage
                end := start + perPage

                if start &gt;= len(comments) </span><span class="cov0" title="0">{
                        comments = []*Comment{}
                }</span> else<span class="cov8" title="1"> {
                        if end &gt; len(comments) </span><span class="cov8" title="1">{
                                end = len(comments)
                        }</span>
                        <span class="cov8" title="1">comments = comments[start:end]

                        // Add Link header for next page if there are more
                        totalPages := (totalComments + perPage - 1) / perPage
                        if page &lt; totalPages </span><span class="cov8" title="1">{
                                nextURL := fmt.Sprintf("%s%s?page=%d", m.Server.URL, r.URL.Path, page+1)
                                w.Header().Set("Link", fmt.Sprintf(`&lt;%s&gt;; rel="next"`, nextURL))
                        }</span>
                }
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(comments)</span>
}

func (m *MockServer) handleCreateComment(w http.ResponseWriter, r *http.Request, number int) <span class="cov8" title="1">{
        m.mu.Lock()
        // Check for forced error first
        if code, body := m.clearError(); code != 0 </span><span class="cov0" title="0">{
                m.mu.Unlock()
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(code)
                w.Write([]byte(body))
                return
        }</span>

        // Check if issue exists
        <span class="cov8" title="1">if _, ok := m.issues[number]; !ok </span><span class="cov8" title="1">{
                m.mu.Unlock()
                http.Error(w, `{"message":"Not Found"}`, http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">var payload struct {
                Body string `json:"body"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                m.mu.Unlock()
                http.Error(w, "invalid json", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC()
        comment := &amp;Comment{
                ID:        m.nextCommentID,
                User:      User{Login: "test-user"},
                Body:      payload.Body,
                CreatedAt: now,
                UpdatedAt: now,
        }
        m.nextCommentID++
        m.comments[number] = append(m.comments[number], comment)
        m.mu.Unlock()

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(comment)</span>
}

func (m *MockServer) handleUpdateComment(w http.ResponseWriter, r *http.Request, commentID int64) <span class="cov8" title="1">{
        m.mu.Lock()
        // Check for forced error first
        if code, body := m.clearError(); code != 0 </span><span class="cov0" title="0">{
                m.mu.Unlock()
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(code)
                w.Write([]byte(body))
                return
        }</span>

        // Find the comment
        <span class="cov8" title="1">var foundComment *Comment
        for _, comments := range m.comments </span><span class="cov8" title="1">{
                for _, c := range comments </span><span class="cov8" title="1">{
                        if c.ID == commentID </span><span class="cov8" title="1">{
                                foundComment = c
                                break</span>
                        }
                }
                <span class="cov8" title="1">if foundComment != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if foundComment == nil </span><span class="cov8" title="1">{
                m.mu.Unlock()
                http.Error(w, `{"message":"Not Found"}`, http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">var payload struct {
                Body string `json:"body"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                m.mu.Unlock()
                http.Error(w, "invalid json", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">foundComment.Body = payload.Body
        foundComment.UpdatedAt = time.Now().UTC()
        m.mu.Unlock()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(foundComment)</span>
}

func (m *MockServer) handleCreateIssue(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        m.mu.Lock()
        // Check for forced error first
        if code, body := m.clearError(); code != 0 </span><span class="cov8" title="1">{
                m.mu.Unlock()
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(code)
                w.Write([]byte(body))
                return
        }</span>

        <span class="cov8" title="1">var payload struct {
                Title  string   `json:"title"`
                Body   string   `json:"body"`
                Labels []string `json:"labels,omitempty"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                m.mu.Unlock()
                http.Error(w, "invalid json", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC()
        etag := `"` + strconv.FormatInt(now.UnixNano(), 16) + `"`

        // Convert labels to Label structs
        labels := make([]Label, len(payload.Labels))
        for i, name := range payload.Labels </span><span class="cov8" title="1">{
                labels[i] = Label{Name: name}
        }</span>

        <span class="cov8" title="1">issue := &amp;Issue{
                Number:    m.nextIssueNum,
                Title:     payload.Title,
                Body:      payload.Body,
                State:     "open",
                Labels:    labels,
                User:      User{Login: "test-user"},
                CreatedAt: now,
                UpdatedAt: now,
                ETag:      etag,
        }
        m.issues[m.nextIssueNum] = issue
        m.nextIssueNum++
        m.mu.Unlock()

        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("ETag", etag)
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(issue)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package logger provides a simple logging system with configurable levels and output.
package logger

import (
        "fmt"
        "io"
        "os"
        "strings"
        "sync"
        "time"
)

// Level represents a log level.
type Level int

const (
        // LevelDebug is the most verbose log level.
        LevelDebug Level = iota
        // LevelInfo is the default log level for general information.
        LevelInfo
        // LevelWarn is for warning messages.
        LevelWarn
        // LevelError is for error messages only.
        LevelError
)

// String returns the string representation of a log level.
func (l Level) String() string <span class="cov8" title="1">{
        switch l </span>{
        case LevelDebug:<span class="cov8" title="1">
                return "DEBUG"</span>
        case LevelInfo:<span class="cov8" title="1">
                return "INFO"</span>
        case LevelWarn:<span class="cov8" title="1">
                return "WARN"</span>
        case LevelError:<span class="cov8" title="1">
                return "ERROR"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// Logger is a simple logger with configurable level and output.
type Logger struct {
        mu     sync.Mutex
        level  Level
        output io.Writer
        file   *os.File // optional log file
}

var defaultLogger = &amp;Logger{
        level:  LevelInfo,
        output: os.Stderr,
}

// SetLevel sets the minimum log level for the default logger.
func SetLevel(level Level) <span class="cov8" title="1">{
        defaultLogger.mu.Lock()
        defer defaultLogger.mu.Unlock()
        defaultLogger.level = level
}</span>

// SetOutput sets the output writer for the default logger.
// This is primarily useful for testing.
func SetOutput(w io.Writer) <span class="cov8" title="1">{
        defaultLogger.mu.Lock()
        defer defaultLogger.mu.Unlock()
        defaultLogger.output = w
}</span>

// SetLogFile opens a log file for writing in addition to the current output.
// The log file will receive all log messages that meet the level threshold.
// Returns an error if the file cannot be opened.
func SetLogFile(path string) error <span class="cov8" title="1">{
        defaultLogger.mu.Lock()
        defer defaultLogger.mu.Unlock()

        // Close existing file if any
        if defaultLogger.file != nil </span><span class="cov8" title="1">{
                defaultLogger.file.Close()
                defaultLogger.file = nil
        }</span>

        <span class="cov8" title="1">f, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to open log file: %w", err)
        }</span>

        <span class="cov8" title="1">defaultLogger.file = f
        return nil</span>
}

// Close closes the log file if one is open.
func Close() <span class="cov8" title="1">{
        defaultLogger.mu.Lock()
        defer defaultLogger.mu.Unlock()

        if defaultLogger.file != nil </span><span class="cov8" title="1">{
                defaultLogger.file.Close()
                defaultLogger.file = nil
        }</span>
}

// log writes a formatted log message if the level meets the threshold.
func (l *Logger) log(level Level, format string, args ...interface{}) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if level &lt; l.level </span><span class="cov8" title="1">{
                return
        }</span>

        // Format: 2006-01-02T15:04:05.000Z LEVEL message
        <span class="cov8" title="1">timestamp := time.Now().UTC().Format("2006-01-02T15:04:05.000Z")
        msg := fmt.Sprintf(format, args...)
        line := fmt.Sprintf("%s %s %s\n", timestamp, level.String(), msg)

        // Write to primary output
        io.WriteString(l.output, line)

        // Also write to file if configured
        if l.file != nil </span><span class="cov8" title="1">{
                io.WriteString(l.file, line)
        }</span>
}

// Debug logs at debug level.
func Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        defaultLogger.log(LevelDebug, format, args...)
}</span>

// Info logs at info level.
func Info(format string, args ...interface{}) <span class="cov8" title="1">{
        defaultLogger.log(LevelInfo, format, args...)
}</span>

// Warn logs at warn level.
func Warn(format string, args ...interface{}) <span class="cov8" title="1">{
        defaultLogger.log(LevelWarn, format, args...)
}</span>

// Error logs at error level.
func Error(format string, args ...interface{}) <span class="cov8" title="1">{
        defaultLogger.log(LevelError, format, args...)
}</span>

// ParseLevel converts a string to a Level.
// Accepts: debug, info, warn, error (case-insensitive).
// Returns an error for unknown level strings.
func ParseLevel(s string) (Level, error) <span class="cov8" title="1">{
        switch strings.ToLower(strings.TrimSpace(s)) </span>{
        case "debug":<span class="cov8" title="1">
                return LevelDebug, nil</span>
        case "info":<span class="cov8" title="1">
                return LevelInfo, nil</span>
        case "warn", "warning":<span class="cov8" title="1">
                return LevelWarn, nil</span>
        case "error":<span class="cov8" title="1">
                return LevelError, nil</span>
        default:<span class="cov8" title="1">
                return LevelInfo, fmt.Errorf("unknown log level %q: valid levels are debug, info, warn, error", s)</span>
        }
}

// GetLevel returns the current log level of the default logger.
func GetLevel() Level <span class="cov8" title="1">{
        defaultLogger.mu.Lock()
        defer defaultLogger.mu.Unlock()
        return defaultLogger.level
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package md provides markdown formatting and parsing for GitHub issues.
package md

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "github.com/JohanCodinha/ghissues/internal/cache"
        "gopkg.in/yaml.v3"
)

// ParsedIssue represents data extracted from a markdown file.
type ParsedIssue struct {
        Number int
        Repo   string
        Title  string
        Body   string
        // Frontmatter fields for reference
        State    string
        Author   string
        ETag     string
        Comments []ParsedComment
}

// ParsedComment represents a comment parsed from markdown.
type ParsedComment struct {
        ID     int64  // 0 for new comments, &gt;0 for existing
        Author string // parsed from header, may be empty for new comments
        Body   string
        IsNew  bool // true if this is a new comment (no valid comment_id)
}

// Changes indicates what was modified between original and parsed issue.
type Changes struct {
        TitleChanged    bool
        BodyChanged     bool
        NewTitle        string
        NewBody         string
        CommentChanges  []CommentChange
        NewComments     []ParsedComment // Comments with IsNew=true
        EditedComments  []CommentChange // Existing comments that were modified
}

// CommentChange represents a change to an existing comment.
type CommentChange struct {
        ID      int64
        NewBody string
}

// frontmatter represents the YAML frontmatter structure.
type frontmatter struct {
        ID        int      `yaml:"id"`
        Repo      string   `yaml:"repo"`
        URL       string   `yaml:"url"`
        State     string   `yaml:"state"`
        Labels    []string `yaml:"labels,omitempty,flow"`
        Author    string   `yaml:"author"`
        CreatedAt string   `yaml:"created_at"`
        UpdatedAt string   `yaml:"updated_at"`
        ETag      string   `yaml:"etag"`
        Comments  int      `yaml:"comments"`
}

// ToMarkdown converts a cache.Issue to markdown format with YAML frontmatter.
// If comments are provided, they are included in a ## Comments section.
func ToMarkdown(issue *cache.Issue, comments ...[]cache.Comment) string <span class="cov8" title="1">{
        var sb strings.Builder

        // Get comments if provided
        var issueComments []cache.Comment
        if len(comments) &gt; 0 </span><span class="cov8" title="1">{
                issueComments = comments[0]
        }</span>

        // Build frontmatter
        <span class="cov8" title="1">fm := frontmatter{
                ID:        issue.Number,
                Repo:      issue.Repo,
                URL:       fmt.Sprintf("https://github.com/%s/issues/%d", issue.Repo, issue.Number),
                State:     issue.State,
                Labels:    issue.Labels,
                Author:    issue.Author,
                CreatedAt: issue.CreatedAt,
                UpdatedAt: issue.UpdatedAt,
                ETag:      issue.ETag,
                Comments:  len(issueComments),
        }

        // Marshal frontmatter to YAML
        yamlBytes, err := yaml.Marshal(&amp;fm)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to minimal frontmatter on error
                sb.WriteString("---\n")
                sb.WriteString(fmt.Sprintf("id: %d\n", issue.Number))
                sb.WriteString(fmt.Sprintf("repo: %s\n", issue.Repo))
                sb.WriteString("---\n")
        }</span> else<span class="cov8" title="1"> {
                sb.WriteString("---\n")
                sb.Write(yamlBytes)
                sb.WriteString("---\n")
        }</span>

        // Add title
        <span class="cov8" title="1">sb.WriteString("\n# ")
        sb.WriteString(issue.Title)
        sb.WriteString("\n")

        // Add body section
        sb.WriteString("\n## Body\n\n")
        sb.WriteString(issue.Body)

        // Ensure body section ends with newline
        if len(issue.Body) &gt; 0 &amp;&amp; !strings.HasSuffix(issue.Body, "\n") </span><span class="cov8" title="1">{
                sb.WriteString("\n")
        }</span>

        // Add comments section if there are comments
        <span class="cov8" title="1">if len(issueComments) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString("\n## Comments\n")

                for _, comment := range issueComments </span><span class="cov8" title="1">{
                        // Format: ### 2026-01-10T14:12:00Z - username
                        sb.WriteString("\n### ")
                        sb.WriteString(comment.CreatedAt)
                        sb.WriteString(" - ")
                        sb.WriteString(comment.Author)
                        sb.WriteString("\n")

                        // Add comment_id HTML comment
                        sb.WriteString(fmt.Sprintf("&lt;!-- comment_id: %d --&gt;\n", comment.ID))

                        // Add comment body
                        sb.WriteString("\n")
                        sb.WriteString(comment.Body)

                        // Ensure comment body ends with newline
                        if len(comment.Body) &gt; 0 &amp;&amp; !strings.HasSuffix(comment.Body, "\n") </span><span class="cov8" title="1">{
                                sb.WriteString("\n")
                        }</span>
                }
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// FromMarkdown parses markdown content and extracts issue data.
// Returns an error if the content is malformed or missing required fields.
func FromMarkdown(content string) (*ParsedIssue, error) <span class="cov8" title="1">{
        parsed := &amp;ParsedIssue{}

        // Extract frontmatter
        fm, remaining, err := extractFrontmatter(content)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse frontmatter: %w", err)
        }</span>

        // Populate from frontmatter
        <span class="cov8" title="1">parsed.Number = fm.ID
        parsed.Repo = fm.Repo
        parsed.State = fm.State
        parsed.Author = fm.Author
        parsed.ETag = fm.ETag

        // Extract title from # heading
        title, remaining := extractTitle(remaining)
        parsed.Title = title

        // Extract body from ## Body section
        body := extractBody(remaining)
        parsed.Body = body

        // Extract comments from ## Comments section
        comments := extractComments(remaining)
        parsed.Comments = comments

        return parsed, nil</span>
}

// DetectChanges compares an original issue with a parsed issue and returns what changed.
func DetectChanges(original *cache.Issue, parsed *ParsedIssue) Changes <span class="cov8" title="1">{
        changes := Changes{}

        // Compare title
        if original.Title != parsed.Title </span><span class="cov8" title="1">{
                changes.TitleChanged = true
                changes.NewTitle = parsed.Title
        }</span>

        // Compare body - normalize trailing whitespace for comparison
        <span class="cov8" title="1">originalBody := strings.TrimRight(original.Body, "\n")
        parsedBody := strings.TrimRight(parsed.Body, "\n")

        if originalBody != parsedBody </span><span class="cov8" title="1">{
                changes.BodyChanged = true
                changes.NewBody = parsed.Body
        }</span>

        <span class="cov8" title="1">return changes</span>
}

// DetectCommentChanges compares parsed comments with original cached comments.
// Returns new comments and edited comments separately.
func DetectCommentChanges(originalComments []cache.Comment, parsedComments []ParsedComment) (newComments []ParsedComment, editedComments []CommentChange) <span class="cov8" title="1">{
        // Build a map of original comment IDs to their bodies
        originalByID := make(map[int64]string)
        for _, c := range originalComments </span><span class="cov8" title="1">{
                originalByID[c.ID] = c.Body
        }</span>

        <span class="cov8" title="1">for _, pc := range parsedComments </span><span class="cov8" title="1">{
                if pc.IsNew || pc.ID == 0 </span><span class="cov8" title="1">{
                        // This is a new comment
                        if strings.TrimSpace(pc.Body) != "" </span><span class="cov8" title="1">{
                                newComments = append(newComments, pc)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Existing comment - check if body changed
                        origBody, exists := originalByID[pc.ID]
                        if exists </span><span class="cov8" title="1">{
                                // Normalize bodies for comparison
                                origNorm := strings.TrimRight(origBody, "\n\r")
                                parsedNorm := strings.TrimRight(pc.Body, "\n\r")
                                if origNorm != parsedNorm </span><span class="cov8" title="1">{
                                        editedComments = append(editedComments, CommentChange{
                                                ID:      pc.ID,
                                                NewBody: pc.Body,
                                        })
                                }</span>
                        }
                        // If ID doesn't exist in original, ignore (orphaned comment reference)
                }
        }

        <span class="cov8" title="1">return newComments, editedComments</span>
}

// extractFrontmatter parses YAML frontmatter from markdown content.
// Returns the parsed frontmatter, remaining content, and any error.
func extractFrontmatter(content string) (*frontmatter, string, error) <span class="cov8" title="1">{
        // Check for frontmatter delimiter
        if !strings.HasPrefix(content, "---") </span><span class="cov8" title="1">{
                return nil, content, fmt.Errorf("missing frontmatter: content must start with ---")
        }</span>

        // Find the closing delimiter
        <span class="cov8" title="1">rest := content[3:] // Skip opening ---

        // Skip any whitespace/newline after opening ---
        rest = strings.TrimLeft(rest, " \t")
        if len(rest) &gt; 0 &amp;&amp; rest[0] == '\n' </span><span class="cov8" title="1">{
                rest = rest[1:]
        }</span> else<span class="cov8" title="1"> if len(rest) &gt; 1 &amp;&amp; rest[0] == '\r' &amp;&amp; rest[1] == '\n' </span><span class="cov8" title="1">{
                rest = rest[2:]
        }</span>

        // Find closing ---
        <span class="cov8" title="1">endIdx := strings.Index(rest, "\n---")
        if endIdx == -1 </span><span class="cov8" title="1">{
                // Try with just --- at start of remaining content
                if strings.HasPrefix(rest, "---") </span><span class="cov0" title="0">{
                        // Empty frontmatter
                        return &amp;frontmatter{}, strings.TrimPrefix(rest, "---"), nil
                }</span>
                <span class="cov8" title="1">return nil, content, fmt.Errorf("missing closing frontmatter delimiter ---")</span>
        }

        <span class="cov8" title="1">yamlContent := rest[:endIdx]
        remaining := rest[endIdx+4:] // Skip \n---

        // Skip newline after closing ---
        if len(remaining) &gt; 0 &amp;&amp; remaining[0] == '\n' </span><span class="cov8" title="1">{
                remaining = remaining[1:]
        }</span> else<span class="cov8" title="1"> if len(remaining) &gt; 1 &amp;&amp; remaining[0] == '\r' &amp;&amp; remaining[1] == '\n' </span><span class="cov8" title="1">{
                remaining = remaining[2:]
        }</span>

        // Parse YAML
        <span class="cov8" title="1">var fm frontmatter
        if err := yaml.Unmarshal([]byte(yamlContent), &amp;fm); err != nil </span><span class="cov8" title="1">{
                return nil, content, fmt.Errorf("invalid YAML in frontmatter: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;fm, remaining, nil</span>
}

// extractTitle extracts the title from a # heading line.
// Returns the title and remaining content after the title line.
func extractTitle(content string) (string, string) <span class="cov8" title="1">{
        lines := strings.SplitN(content, "\n", -1)

        for i, line := range lines </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if strings.HasPrefix(trimmed, "# ") </span><span class="cov8" title="1">{
                        title := strings.TrimPrefix(trimmed, "# ")
                        // Return remaining content after this line
                        remaining := strings.Join(lines[i+1:], "\n")
                        return title, remaining
                }</span>
        }

        <span class="cov8" title="1">return "", content</span>
}

// extractBody extracts the body content from the ## Body section.
// The body section ends at the next ## heading or end of file.
func extractBody(content string) string <span class="cov8" title="1">{
        // Find ## Body section
        bodyPattern := regexp.MustCompile(`(?m)^## Body\s*$`)
        loc := bodyPattern.FindStringIndex(content)
        if loc == nil </span><span class="cov8" title="1">{
                // No ## Body section found - return empty
                return ""
        }</span>

        // Start after the ## Body line
        <span class="cov8" title="1">afterHeader := content[loc[1]:]

        // Skip leading newline after ## Body
        if len(afterHeader) &gt; 0 &amp;&amp; afterHeader[0] == '\n' </span><span class="cov8" title="1">{
                afterHeader = afterHeader[1:]
        }</span> else<span class="cov8" title="1"> if len(afterHeader) &gt; 1 &amp;&amp; afterHeader[0] == '\r' &amp;&amp; afterHeader[1] == '\n' </span><span class="cov0" title="0">{
                afterHeader = afterHeader[2:]
        }</span>

        // Find next ## heading (end of body section)
        <span class="cov8" title="1">nextSectionPattern := regexp.MustCompile(`(?m)^## `)
        nextLoc := nextSectionPattern.FindStringIndex(afterHeader)

        var body string
        if nextLoc != nil </span><span class="cov8" title="1">{
                body = afterHeader[:nextLoc[0]]
        }</span> else<span class="cov8" title="1"> {
                body = afterHeader
        }</span>

        // Trim trailing newlines but preserve internal structure
        <span class="cov8" title="1">body = strings.TrimRight(body, "\n\r")

        return body</span>
}

// commentHeaderRegex matches comment headers: ### timestamp - author
var commentHeaderRegex = regexp.MustCompile(`(?m)^### (.+?) - (.+)$`)

// commentIDRegex matches the comment_id HTML comment: &lt;!-- comment_id: 123 --&gt;
var commentIDRegex = regexp.MustCompile(`&lt;!--\s*comment_id:\s*(\w+)\s*--&gt;`)

// extractComments parses the ## Comments section and extracts individual comments.
// Comments are expected in the format:
//
//        ### 2026-01-10T14:12:00Z - alice
//        &lt;!-- comment_id: 987654 --&gt;
//
//        Comment body here.
//
// For new comments, the header can be:
//
//        ### new
//        &lt;!-- comment_id: new --&gt;
//
//        New comment body.
func extractComments(content string) []ParsedComment <span class="cov8" title="1">{
        // Find ## Comments section
        commentsPattern := regexp.MustCompile(`(?m)^## Comments\s*$`)
        loc := commentsPattern.FindStringIndex(content)
        if loc == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Start after the ## Comments line
        <span class="cov8" title="1">afterHeader := content[loc[1]:]

        // Skip leading newline
        if len(afterHeader) &gt; 0 &amp;&amp; afterHeader[0] == '\n' </span><span class="cov8" title="1">{
                afterHeader = afterHeader[1:]
        }</span>

        // Find the next ## heading (if any, to delimit the comments section)
        <span class="cov8" title="1">nextSectionPattern := regexp.MustCompile(`(?m)^## [^#]`)
        nextLoc := nextSectionPattern.FindStringIndex(afterHeader)
        var commentsSection string
        if nextLoc != nil </span><span class="cov0" title="0">{
                commentsSection = afterHeader[:nextLoc[0]]
        }</span> else<span class="cov8" title="1"> {
                commentsSection = afterHeader
        }</span>

        // Split into individual comments by ### headers
        // Each comment starts with ### (timestamp - author) or ### new
        <span class="cov8" title="1">commentBlocks := splitCommentBlocks(commentsSection)

        var comments []ParsedComment
        for _, block := range commentBlocks </span><span class="cov8" title="1">{
                comment := parseCommentBlock(block)
                if comment != nil </span><span class="cov8" title="1">{
                        comments = append(comments, *comment)
                }</span>
        }

        <span class="cov8" title="1">return comments</span>
}

// splitCommentBlocks splits the comments section into individual comment blocks.
// Each block starts with ### and ends before the next ### or end of content.
func splitCommentBlocks(content string) []string <span class="cov8" title="1">{
        headerPattern := regexp.MustCompile(`(?m)^### `)
        indices := headerPattern.FindAllStringIndex(content, -1)

        if len(indices) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var blocks []string
        for i, loc := range indices </span><span class="cov8" title="1">{
                start := loc[0]
                var end int
                if i+1 &lt; len(indices) </span><span class="cov8" title="1">{
                        end = indices[i+1][0]
                }</span> else<span class="cov8" title="1"> {
                        end = len(content)
                }</span>
                <span class="cov8" title="1">block := content[start:end]
                blocks = append(blocks, block)</span>
        }

        <span class="cov8" title="1">return blocks</span>
}

// parseCommentBlock parses a single comment block and returns a ParsedComment.
// Returns nil if the block is invalid.
func parseCommentBlock(block string) *ParsedComment <span class="cov8" title="1">{
        lines := strings.SplitN(block, "\n", -1)
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // First line should be the header: ### timestamp - author or ### new
        <span class="cov8" title="1">headerLine := strings.TrimSpace(lines[0])
        if !strings.HasPrefix(headerLine, "### ") </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">header := strings.TrimPrefix(headerLine, "### ")
        comment := &amp;ParsedComment{}

        // Check if this is a "new" comment
        if strings.ToLower(strings.TrimSpace(header)) == "new" </span><span class="cov8" title="1">{
                comment.IsNew = true
                comment.ID = 0
        }</span> else<span class="cov8" title="1"> {
                // Try to parse as "timestamp - author"
                matches := commentHeaderRegex.FindStringSubmatch(headerLine)
                if matches != nil &amp;&amp; len(matches) &gt;= 3 </span><span class="cov8" title="1">{
                        comment.Author = matches[2]
                }</span>
        }

        // Look for comment_id in the remaining lines
        <span class="cov8" title="1">var bodyStartIdx int
        for i, line := range lines[1:] </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)

                // Look for comment_id HTML comment
                if idMatch := commentIDRegex.FindStringSubmatch(trimmed); idMatch != nil </span><span class="cov8" title="1">{
                        idStr := idMatch[1]
                        if strings.ToLower(idStr) == "new" </span><span class="cov8" title="1">{
                                comment.IsNew = true
                                comment.ID = 0
                        }</span> else<span class="cov8" title="1"> {
                                id, err := strconv.ParseInt(idStr, 10, 64)
                                if err == nil </span><span class="cov8" title="1">{
                                        comment.ID = id
                                }</span> else<span class="cov0" title="0"> {
                                        // Invalid ID format, treat as new
                                        comment.IsNew = true
                                        comment.ID = 0
                                }</span>
                        }
                        <span class="cov8" title="1">bodyStartIdx = i + 2 // Skip to line after comment_id
                        continue</span>
                }

                // Empty lines before body
                <span class="cov8" title="1">if trimmed == "" &amp;&amp; bodyStartIdx == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Start of body content
                <span class="cov8" title="1">if bodyStartIdx == 0 &amp;&amp; trimmed != "" </span><span class="cov8" title="1">{
                        bodyStartIdx = i + 1
                }</span>
        }

        // Extract body from the remaining lines
        <span class="cov8" title="1">if bodyStartIdx &gt; 0 &amp;&amp; bodyStartIdx &lt; len(lines) </span><span class="cov8" title="1">{
                bodyLines := lines[bodyStartIdx:]
                // Skip leading empty lines
                for len(bodyLines) &gt; 0 &amp;&amp; strings.TrimSpace(bodyLines[0]) == "" </span><span class="cov8" title="1">{
                        bodyLines = bodyLines[1:]
                }</span>
                <span class="cov8" title="1">body := strings.Join(bodyLines, "\n")
                body = strings.TrimRight(body, "\n\r")
                comment.Body = body</span>
        }

        <span class="cov8" title="1">return comment</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package sync provides the synchronization engine between local cache and GitHub.
package sync

import (
        "fmt"
        "strings"
        gosync "sync"
        "time"

        "github.com/JohanCodinha/ghissues/internal/cache"
        "github.com/JohanCodinha/ghissues/internal/gh"
        "github.com/JohanCodinha/ghissues/internal/logger"
)

// Engine handles synchronization between cache and GitHub.
type Engine struct {
        cache      *cache.DB
        client     *gh.Client
        repo       string // "owner/repo"
        owner      string
        repoName   string
        debounceMs int

        // internal state
        mu     gosync.Mutex
        timer  *time.Timer
        stopCh chan struct{}
}

// NewEngine creates a new sync engine.
// repo should be in "owner/repo" format.
// debounceMs is the debounce delay in milliseconds for write syncs.
func NewEngine(cacheDB *cache.DB, client *gh.Client, repo string, debounceMs int) (*Engine, error) <span class="cov8" title="1">{
        owner, repoName, err := parseRepo(repo)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Engine{
                cache:      cacheDB,
                client:     client,
                repo:       repo,
                owner:      owner,
                repoName:   repoName,
                debounceMs: debounceMs,
                stopCh:     make(chan struct{}),
        }, nil</span>
}

// parseRepo splits "owner/repo" into owner and repo name.
func parseRepo(repo string) (string, string, error) <span class="cov8" title="1">{
        parts := strings.SplitN(repo, "/", 2)
        if len(parts) != 2 || parts[0] == "" || parts[1] == "" </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("invalid repo format %q: must be owner/repo", repo)
        }</span>
        <span class="cov8" title="1">return parts[0], parts[1], nil</span>
}

// ghIssueToCacheIssue converts a GitHub issue to a cache issue.
func (e *Engine) ghIssueToCacheIssue(ghIssue *gh.Issue) cache.Issue <span class="cov8" title="1">{
        labels := make([]string, len(ghIssue.Labels))
        for i, l := range ghIssue.Labels </span><span class="cov8" title="1">{
                labels[i] = l.Name
        }</span>

        <span class="cov8" title="1">return cache.Issue{
                Number:    ghIssue.Number,
                Repo:      e.repo,
                Title:     ghIssue.Title,
                Body:      ghIssue.Body,
                State:     ghIssue.State,
                Author:    ghIssue.User.Login,
                Labels:    labels,
                CreatedAt: ghIssue.CreatedAt.Format(time.RFC3339),
                UpdatedAt: ghIssue.UpdatedAt.Format(time.RFC3339),
                ETag:      ghIssue.ETag,
                Dirty:     false,
        }</span>
}

// InitialSync fetches all issues from GitHub and populates the cache.
// This should be called on mount.
func (e *Engine) InitialSync() error <span class="cov8" title="1">{
        logger.Debug("sync: starting initial sync for %s", e.repo)

        issues, err := e.client.ListIssues(e.owner, e.repoName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list issues: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Debug("sync: fetched %d issues from GitHub", len(issues))

        for _, ghIssue := range issues </span><span class="cov8" title="1">{
                cacheIssue := e.ghIssueToCacheIssue(&amp;ghIssue)
                if err := e.cache.UpsertIssue(cacheIssue); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("sync: failed to upsert issue #%d: %v", ghIssue.Number, err)
                        // Continue with other issues
                }</span>

                // Fetch comments for this issue
                <span class="cov8" title="1">if err := e.syncComments(ghIssue.Number); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("sync: failed to sync comments for issue #%d: %v", ghIssue.Number, err)
                        // Continue with other issues
                }</span>
        }

        <span class="cov8" title="1">logger.Debug("sync: initial sync complete")
        return nil</span>
}

// syncComments fetches and caches comments for an issue.
func (e *Engine) syncComments(number int) error <span class="cov8" title="1">{
        ghComments, err := e.client.ListComments(e.owner, e.repoName, number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list comments: %w", err)
        }</span>

        // Convert gh.Comment to cache.Comment
        <span class="cov8" title="1">cacheComments := make([]cache.Comment, len(ghComments))
        for i, ghComment := range ghComments </span><span class="cov8" title="1">{
                cacheComments[i] = cache.Comment{
                        ID:          ghComment.ID,
                        IssueNumber: number,
                        Repo:        e.repo,
                        Author:      ghComment.User.Login,
                        Body:        ghComment.Body,
                        CreatedAt:   ghComment.CreatedAt.Format(time.RFC3339),
                        UpdatedAt:   ghComment.UpdatedAt.Format(time.RFC3339),
                }
        }</span>

        <span class="cov8" title="1">if err := e.cache.UpsertComments(e.repo, number, cacheComments); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upsert comments: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Debug("sync: synced %d comments for issue #%d", len(cacheComments), number)
        return nil</span>
}

// RefreshIssue fetches a single issue if the etag has changed (background refresh).
// Returns true if the issue was updated in cache, false if unchanged or error.
// This uses conditional requests with If-None-Match header.
func (e *Engine) RefreshIssue(number int) (bool, error) <span class="cov8" title="1">{
        // Get the current cached issue to get its etag
        cachedIssue, err := e.cache.GetIssue(e.repo, number)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get cached issue: %w", err)
        }</span>
        <span class="cov8" title="1">if cachedIssue == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("issue #%d not found in cache", number)
        }</span>

        // Don't refresh dirty issues - local changes take precedence
        <span class="cov8" title="1">if cachedIssue.Dirty </span><span class="cov8" title="1">{
                logger.Debug("sync: skipping refresh for dirty issue #%d", number)
                return false, nil
        }</span>

        // Fetch with etag for conditional request
        <span class="cov8" title="1">ghIssue, _, err := e.client.GetIssueWithEtag(e.owner, e.repoName, number, cachedIssue.ETag)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to fetch issue: %w", err)
        }</span>

        // 304 Not Modified - issue hasn't changed
        <span class="cov8" title="1">if ghIssue == nil </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // Issue was updated - update cache
        // Note: ghIssue.ETag is set by GetIssueWithEtag, newEtag is the same value
        <span class="cov8" title="1">cacheIssue := e.ghIssueToCacheIssue(ghIssue)
        if err := e.cache.UpsertIssue(cacheIssue); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to update cache: %w", err)
        }</span>

        // Also refresh comments for this issue
        <span class="cov8" title="1">if err := e.syncComments(number); err != nil </span><span class="cov0" title="0">{
                logger.Warn("sync: failed to refresh comments for issue #%d: %v", number, err)
                // Don't fail the whole refresh - issue update succeeded
        }</span>

        <span class="cov8" title="1">logger.Debug("sync: refreshed issue #%d from GitHub", number)
        return true, nil</span>
}

// TriggerSync schedules a debounced sync of dirty issues.
// Multiple calls within the debounce window reset the timer.
func (e *Engine) TriggerSync() <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        // Stop existing timer if any
        if e.timer != nil </span><span class="cov8" title="1">{
                e.timer.Stop()
        }</span>

        // Start new timer
        <span class="cov8" title="1">e.timer = time.AfterFunc(time.Duration(e.debounceMs)*time.Millisecond, func() </span><span class="cov8" title="1">{
                // Sync pending new issues first (so they get issue numbers before comments are added)
                if err := e.syncPendingIssues(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("sync: error syncing pending issues: %v", err)
                }</span>
                // Sync pending new comments (can now reference correct issue numbers)
                <span class="cov8" title="1">if err := e.syncPendingComments(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("sync: error syncing pending comments: %v", err)
                }</span>
                // Sync dirty (edited) comments
                <span class="cov8" title="1">if err := e.syncDirtyComments(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("sync: error syncing dirty comments: %v", err)
                }</span>
                // Sync dirty issues
                <span class="cov8" title="1">if err := e.syncDirtyIssues(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("sync: error syncing dirty issues: %v", err)
                }</span>
        })

        <span class="cov8" title="1">logger.Debug("sync: debounce timer started/reset (%dms)", e.debounceMs)</span>
}

// SyncNow immediately syncs all dirty issues, comments, and pending items.
// This should be called on unmount to ensure all changes are pushed.
func (e *Engine) SyncNow() error <span class="cov8" title="1">{
        e.mu.Lock()
        // Stop any pending timer
        if e.timer != nil </span><span class="cov8" title="1">{
                e.timer.Stop()
                e.timer = nil
        }</span>
        <span class="cov8" title="1">e.mu.Unlock()

        var errs []error

        // Sync pending new issues first (so they get issue numbers before comments are added)
        if err := e.syncPendingIssues(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("pending issues: %w", err))
        }</span>

        // Sync pending new comments (can now reference correct issue numbers)
        <span class="cov8" title="1">if err := e.syncPendingComments(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("pending comments: %w", err))
        }</span>

        // Sync dirty (edited) comments
        <span class="cov8" title="1">if err := e.syncDirtyComments(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("dirty comments: %w", err))
        }</span>

        // Sync dirty issues
        <span class="cov8" title="1">if err := e.syncDirtyIssues(); err != nil </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("dirty issues: %w", err))
        }</span>

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                // Join multiple errors into a single error with context
                errMsgs := make([]string, len(errs))
                for i, e := range errs </span><span class="cov8" title="1">{
                        errMsgs[i] = e.Error()
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("sync errors: %s", strings.Join(errMsgs, "; "))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// syncDirtyIssues syncs all dirty issues to GitHub.
func (e *Engine) syncDirtyIssues() error <span class="cov8" title="1">{
        dirtyIssues, err := e.cache.GetDirtyIssues(e.repo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get dirty issues: %w", err)
        }</span>

        <span class="cov8" title="1">if len(dirtyIssues) == 0 </span><span class="cov8" title="1">{
                logger.Debug("sync: no dirty issues to sync")
                return nil
        }</span>

        <span class="cov8" title="1">logger.Debug("sync: syncing %d dirty issues", len(dirtyIssues))

        var syncErrors []error
        for _, issue := range dirtyIssues </span><span class="cov8" title="1">{
                if err := e.syncIssue(issue); err != nil </span><span class="cov8" title="1">{
                        syncErrors = append(syncErrors, fmt.Errorf("issue #%d: %w", issue.Number, err))
                }</span>
        }

        <span class="cov8" title="1">if len(syncErrors) &gt; 0 </span><span class="cov8" title="1">{
                errMsgs := make([]string, len(syncErrors))
                for i, e := range syncErrors </span><span class="cov8" title="1">{
                        errMsgs[i] = e.Error()
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to sync %d dirty issues: %s", len(syncErrors), strings.Join(errMsgs, "; "))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// syncIssue syncs a single dirty issue to GitHub.
// Implements conflict detection: local wins UNLESS remote was updated more recently.
func (e *Engine) syncIssue(issue cache.Issue) error <span class="cov8" title="1">{
        logger.Debug("sync: checking conflict for issue #%d", issue.Number)

        // Fetch remote to check updated_at
        remoteIssue, _, err := e.client.GetIssue(e.owner, e.repoName, issue.Number)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to fetch remote issue: %w", err)
        }</span>

        // Parse timestamps for conflict detection
        <span class="cov8" title="1">localUpdatedAt, err := time.Parse(time.RFC3339, issue.LocalUpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse local_updated_at: %w", err)
        }</span>

        <span class="cov8" title="1">remoteUpdatedAt := remoteIssue.UpdatedAt

        // Conflict detection: if remote is newer, skip push (keep dirty for user to resolve)
        if remoteUpdatedAt.After(localUpdatedAt) </span><span class="cov8" title="1">{
                logger.Warn("sync: conflict detected for issue #%d - remote is newer (remote: %s, local: %s), keeping dirty",
                        issue.Number, remoteUpdatedAt.Format(time.RFC3339), localUpdatedAt.Format(time.RFC3339))
                // Per design: local wins UNLESS remote is newer
                // So if remote is newer, we skip push and keep the issue dirty
                return nil
        }</span>

        // Determine which fields changed and need to be pushed
        <span class="cov8" title="1">var titlePtr, bodyPtr *string
        if issue.Title != remoteIssue.Title </span><span class="cov8" title="1">{
                titlePtr = &amp;issue.Title
        }</span>
        <span class="cov8" title="1">if issue.Body != remoteIssue.Body </span><span class="cov8" title="1">{
                bodyPtr = &amp;issue.Body
        }</span>

        // Push update to GitHub (only if something changed)
        <span class="cov8" title="1">if titlePtr != nil || bodyPtr != nil </span><span class="cov8" title="1">{
                logger.Debug("sync: pushing issue #%d to GitHub (title changed: %v, body changed: %v)",
                        issue.Number, titlePtr != nil, bodyPtr != nil)
                if err := e.client.UpdateIssue(e.owner, e.repoName, issue.Number, titlePtr, bodyPtr); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update issue on GitHub: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Debug("sync: issue #%d marked dirty but no changes detected, clearing dirty flag", issue.Number)
        }</span>

        // Clear dirty flag on success
        <span class="cov8" title="1">if err := e.cache.ClearDirty(e.repo, issue.Number); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear dirty flag: %w", err)
        }</span>

        // Refresh the issue to get updated etag and updated_at
        <span class="cov8" title="1">if _, err := e.RefreshIssue(issue.Number); err != nil </span><span class="cov0" title="0">{
                // Log but don't fail - the sync itself succeeded
                logger.Warn("sync: failed to refresh issue #%d after sync: %v", issue.Number, err)
        }</span>

        <span class="cov8" title="1">logger.Debug("sync: successfully synced issue #%d", issue.Number)
        return nil</span>
}

// Stop stops the sync engine and any pending timers.
func (e *Engine) Stop() <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if e.timer != nil </span><span class="cov8" title="1">{
                e.timer.Stop()
                e.timer = nil
        }</span>

        // Signal stop (for any future background goroutines)
        <span class="cov8" title="1">select </span>{
        case &lt;-e.stopCh:<span class="cov8" title="1"></span>
                // Already closed
        default:<span class="cov8" title="1">
                close(e.stopCh)</span>
        }

        <span class="cov8" title="1">logger.Debug("sync: engine stopped")</span>
}

// HasConflict checks if an issue has a conflict (remote is newer than local).
// Returns true if remote updated_at &gt; local local_updated_at.
func (e *Engine) HasConflict(number int) (bool, error) <span class="cov8" title="1">{
        cachedIssue, err := e.cache.GetIssue(e.repo, number)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to get cached issue: %w", err)
        }</span>
        <span class="cov8" title="1">if cachedIssue == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("issue #%d not found in cache", number)
        }</span>

        <span class="cov8" title="1">if !cachedIssue.Dirty </span><span class="cov8" title="1">{
                return false, nil // Not dirty, no conflict possible
        }</span>

        // Fetch remote
        <span class="cov8" title="1">remoteIssue, _, err := e.client.GetIssue(e.owner, e.repoName, number)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to fetch remote issue: %w", err)
        }</span>

        <span class="cov8" title="1">localUpdatedAt, err := time.Parse(time.RFC3339, cachedIssue.LocalUpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to parse local_updated_at: %w", err)
        }</span>

        <span class="cov8" title="1">return remoteIssue.UpdatedAt.After(localUpdatedAt), nil</span>
}

// syncPendingComments syncs all pending (new) comments to GitHub.
func (e *Engine) syncPendingComments() error <span class="cov8" title="1">{
        pendingComments, err := e.cache.GetPendingComments(e.repo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get pending comments: %w", err)
        }</span>

        <span class="cov8" title="1">if len(pendingComments) == 0 </span><span class="cov8" title="1">{
                logger.Debug("sync: no pending comments to sync")
                return nil
        }</span>

        <span class="cov8" title="1">logger.Debug("sync: syncing %d pending comments", len(pendingComments))

        var syncErrors []error
        for _, pc := range pendingComments </span><span class="cov8" title="1">{
                // Create the comment on GitHub
                _, err := e.client.CreateComment(e.owner, e.repoName, pc.IssueNumber, pc.Body)
                if err != nil </span><span class="cov0" title="0">{
                        syncErrors = append(syncErrors, fmt.Errorf("comment for issue #%d: %w", pc.IssueNumber, err))
                        continue</span>
                }

                // Remove from pending after successful sync
                <span class="cov8" title="1">if err := e.cache.RemovePendingComment(pc.ID); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("sync: failed to remove pending comment %d: %v", pc.ID, err)
                }</span>

                // Refresh comments for this issue to get the new comment in cache
                <span class="cov8" title="1">if err := e.syncComments(pc.IssueNumber); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("sync: failed to refresh comments for issue #%d: %v", pc.IssueNumber, err)
                }</span>

                <span class="cov8" title="1">logger.Debug("sync: created comment on issue #%d", pc.IssueNumber)</span>
        }

        <span class="cov8" title="1">if len(syncErrors) &gt; 0 </span><span class="cov0" title="0">{
                errMsgs := make([]string, len(syncErrors))
                for i, e := range syncErrors </span><span class="cov0" title="0">{
                        errMsgs[i] = e.Error()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to sync %d pending comments: %s", len(syncErrors), strings.Join(errMsgs, "; "))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// syncDirtyComments syncs all dirty (edited) comments to GitHub.
func (e *Engine) syncDirtyComments() error <span class="cov8" title="1">{
        dirtyComments, err := e.cache.GetDirtyComments(e.repo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get dirty comments: %w", err)
        }</span>

        <span class="cov8" title="1">if len(dirtyComments) == 0 </span><span class="cov8" title="1">{
                logger.Debug("sync: no dirty comments to sync")
                return nil
        }</span>

        <span class="cov8" title="1">logger.Debug("sync: syncing %d dirty comments", len(dirtyComments))

        var syncErrors []error
        for _, dc := range dirtyComments </span><span class="cov8" title="1">{
                // Update the comment on GitHub
                err := e.client.UpdateComment(e.owner, e.repoName, dc.ID, dc.Body)
                if err != nil </span><span class="cov0" title="0">{
                        syncErrors = append(syncErrors, fmt.Errorf("comment %d: %w", dc.ID, err))
                        continue</span>
                }

                // Clear dirty flag after successful sync
                <span class="cov8" title="1">if err := e.cache.ClearCommentDirty(e.repo, dc.ID); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("sync: failed to clear dirty flag for comment %d: %v", dc.ID, err)
                }</span>

                <span class="cov8" title="1">logger.Debug("sync: updated comment %d on issue #%d", dc.ID, dc.IssueNumber)</span>
        }

        <span class="cov8" title="1">if len(syncErrors) &gt; 0 </span><span class="cov0" title="0">{
                errMsgs := make([]string, len(syncErrors))
                for i, e := range syncErrors </span><span class="cov0" title="0">{
                        errMsgs[i] = e.Error()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to sync %d dirty comments: %s", len(syncErrors), strings.Join(errMsgs, "; "))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// syncPendingIssues syncs all pending (new) issues to GitHub.
func (e *Engine) syncPendingIssues() error <span class="cov8" title="1">{
        pendingIssues, err := e.cache.GetPendingIssues(e.repo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get pending issues: %w", err)
        }</span>

        <span class="cov8" title="1">if len(pendingIssues) == 0 </span><span class="cov8" title="1">{
                logger.Debug("sync: no pending issues to sync")
                return nil
        }</span>

        <span class="cov8" title="1">logger.Debug("sync: syncing %d pending issues", len(pendingIssues))

        var syncErrors []error
        for _, pi := range pendingIssues </span><span class="cov8" title="1">{
                // Create the issue on GitHub
                ghIssue, err := e.client.CreateIssue(e.owner, e.repoName, pi.Title, pi.Body, pi.Labels)
                if err != nil </span><span class="cov0" title="0">{
                        syncErrors = append(syncErrors, fmt.Errorf("issue %q: %w", pi.Title, err))
                        continue</span>
                }

                // Remove from pending after successful sync
                <span class="cov8" title="1">if err := e.cache.RemovePendingIssue(pi.ID); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("sync: failed to remove pending issue %d: %v", pi.ID, err)
                }</span>

                // Add the newly created issue to the cache
                <span class="cov8" title="1">cacheIssue := e.ghIssueToCacheIssue(ghIssue)
                if err := e.cache.UpsertIssue(cacheIssue); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("sync: failed to cache newly created issue #%d: %v", ghIssue.Number, err)
                }</span>

                <span class="cov8" title="1">logger.Debug("sync: created issue #%d: %s", ghIssue.Number, ghIssue.Title)</span>
        }

        <span class="cov8" title="1">if len(syncErrors) &gt; 0 </span><span class="cov0" title="0">{
                errMsgs := make([]string, len(syncErrors))
                for i, e := range syncErrors </span><span class="cov0" title="0">{
                        errMsgs[i] = e.Error()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to sync %d pending issues: %s", len(syncErrors), strings.Join(errMsgs, "; "))</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
